---
title: "Esercitazione 1"
subtitle: "Analisi dell'onda pressoria arteriosa"
author: "Paolo Rossi, 235651"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(dplyr)
library(ggplot2)
library(plotly)
library(patchwork)
library(stats)
library(purrr)

source("dig_signal_proc.R")

```

Per la consegna dell'esercitazione si faccia riferimento a questo [link](https://mmt-unitn.github.io/EsercitazioniCasaDARE/2_CostruzioneSegnaleFiltraggio/DARE_2_CostruzioneSegnaleFiltraggio.html#interpolazione-a-tratti). Mentre le librerie sono rimandate nell'icona `Librerie`.

**Parametri di campionamento** che verranno considerati nell'analisi:

```{r}
# Campionamento regolare
fs <- 1000      # freq. di campionamento
Ts <- 1/fs      # periodo di campionamento
```


# Costruzione onda pressoria

Un metodo per interpolare dei punti è mediante una **funzione spline**. Peraltro, questa permette di costruire una funzione "smussata", priva di punti singolari nel dominio interpolato.

Inizialmente è stata costruita una **spline cubica naturale**, che però introduce un nuovo punto di minimo in corrispondenza di $t \approx 0.75\,\mathrm{s}$. Dunque, per garantire che venga seguito il profilo dei punti interpolati (i.e.: è necessario seguire il più possibile l'interpolazione lineare tra i diversi punti), si possono seguire due approcci:

* infittire i punti da interpolare laddove c'è una deviazione dal comportamento desiderato, ed eventualmente attribuirgli maggior importanza;

* **Suggerimento ChatGPT:** costruire una spline monotona shape-preserving, che consente una monotonia locale al variare dei valori del dominio e quindi permette di conservare il profilo desiderato.

Come soluzione è stato scelto l'**approccio proposto dall'intelligenza artificiale**.

:::{.exam-points}
Funzione di interpolazione.
:::

```{r}
# Punti da interpolare
tind  <- c(0, 0.1, 0.2, 0.3, 0.5, 1)   # istanti "chiave"
tval  <- c(80, 120, 100, 105, 90, 80)  # valori ai tempi chiave

# Funzione spline cubica naturale
p_spline <- splinefun(x = tind, y = tval, method = "natural")

# Segnale di onda pressoria
Ta <- max(tind) - min(tind) # tempo di acquisizioni
N <- fs*Ta                  # numero di campioni

sig_art <- tibble(
  n = 0:(N-1),
  t = n/fs,
  p_art = p_spline(t)
)

p1 <- sig_art %>% ggplot(aes(x = t, y = p_art)) +
  geom_line(color = "blue") +
  labs(x = "Tempo (s)", y = "Pressione (mmHg)", title = "Spline cubica naturale")
```

```{r}
# Spline monotona shape-preserving
p_spline <- splinefun(x = tind, y = tval, method = "monoH.FC")

# Segnale di onda pressoria
sig_art <- tibble(
  n = 0:(N-1),
  t = n/fs,
  p_art = p_spline(t)
)

p2 <- sig_art %>% ggplot(aes(x = t, y = p_art)) +
  geom_line(color = "blue") +
  labs(x = "Tempo (s)", y = "Pressione (mmHg)", title = "Spline monotona shape-preserving")

p1+p2
```

Simulando **dieci battiti cardiaci**, il segnale complessivo risulta come segue.

```{r include=FALSE}
# Piecewise linear interpolation (del professore)
interp_fun <- function(ti, tind, tval) {
  # "ti" istante da interpolare, "tind" istanti "chiave", "tval" valori ai tempi chiave
  Dt <- ti - tind
  Dt <- Dt[Dt>=0]
  ii <- length(Dt)

  Dt <- Dt[ii] # scarto con tempo chiave corrente

  t_p <- tind[ii] # valore temporale chiave precedente
  val_p <- tval[ii] # valore chiave precedente

  t_d <- tind[ii+1]  # valore temporale chiave successivo
  val_d <- tval[ii+1]  # valore chiave successivo

  # Interpolazione lineare e restituzione valore in uscita della funzione
  val_p + Dt * (val_d - val_p) / (t_d - t_p)
}

t <- seq(from = 0, to = 1, by = 0.001)  # base dei tempi

p_art <- map_dbl(t[1:length(t)-1], \(t) interp_fun(t, tind, tval))

t <- t[1:length(t)-1]


# Simuliamo 10 battiti cardiaci
p_art <- rep(p_art, 10)
t <- seq(from = 0, to = 0.001*(length(p_art)-1), by = 0.001)

```


```{r}
# Ripetizione per 10 battiti
Ta <- 10
N <- fs*Ta

sig_art <- tibble(
  n = 0:(N-1),
  t = n/fs,
  p_art = rep(sig_art$p_art, times = 10)
)

plot_ly() %>%
  add_lines(x = t, y = p_art, line = list(color = "red", width = 2.5), name = "Interp. lineare") %>%
  add_lines(x = sig_art$t, y = sig_art$p_art, line = list(color = "blue", width = 1.5, dash="dashdot"), name = "Spline") %>%
  layout(xaxis = list(title = "Tempo (s)"), yaxis = list(title = "Pressione (mmHg)"), title = "Onda pressoria")
```

Si mette in rilievo la presenza di una **cuspide** ad ogni intero di periodo $T = 1\,\mathrm{s}$. Per sistemare il problema si potrebbero imporre delle condizioni sul valore e sulle derivate tra le ripetizioni in corrispondenza di quei punti. Ciononostante, considerando che non è immediato il codice e che **il segnale analizzato sarà quello ricostruito mediante le serie di Fourier**, si trascura questo aspetto.

## Ricostruzione mediante serie di Fourier

Il segnale viene ricostruito mediante le serie di Fourier, in cui l'$n$-esimo elemento vale:

$$
p[n] = a_0 + \sum_{k = 1}^{K} a_k \cos[2\pi k f_0 \, n] + \sum_{k = 1}^{K} a_k \sin[2\pi k f_0  \, n] ,
$$

dove $f_0$ è la frequenza fondamentale, $K$ è il numero totale di componenti armoniche e $a_k, b_k$ sono le $k$-esime componenti, risultato della [scomposizione su basi orto-normali](https://mmt-unitn.github.io/EsercitazioniAulaDARE/DARE_EsAula1_%20ProdScalareFunz.html). Si osservi che la **componente in DC** non viene divisa per 2, perché è calcolata come la media del segnale, anziché il doppio della media (come da teoria della [trasformata](https://mmt-unitn.github.io/EsercitazioniAulaDARE/DARE_EsAula1_%20ProdScalareFunz.html)).

La $k$-esima componente avrà frequenza pari a $f_k = k f_0 = \frac{k}{T_a}$, dove $T_a = `r Ta`\,\mathrm{s}$ è il tempo di  acquisizione. Perciò, in virtù del Teorema di Nyquist-Shannon, deve valere la seguente disuguaglianza, per la quale si calcola la **massima componente**:

$$
f_{max} = \frac{k_{max}}{T_a} \leq \frac{f_s}2 \Leftrightarrow k_{max} = \frac{f_s T_a}{2} = 5000, 
$$
con $f_s = `r fs`\,\mathrm{Hz}$ la frequenza di campionamento.

::: {.exam-points}
Ricostruzione segnale anche con i coseni.
:::
```{r}
a0 <- mean(sig_art$p_art)

# La componente DC è ortogonale alle basi seno e cose
# Per evitare errori numerici, quest'ultima viene sottratta al segnale
p_art_osc <- sig_art$p_art - a0

K <- 500 # massimo possibile: 5e3
f_fund <- 1/Ta

comps_cos <- map_dbl(1:K, \(k) {
  c <- cos_k(sig_art$t, f_fund, k)
  p_art_osc %ps% c/norm_ps(c)
}) %>% zapsmall()

comps_sin <- map_dbl(1:K, \(k) {
  s <- sin_k(sig_art$t, f_fund, k)
  p_art_osc %ps% s/norm_ps(s)
}) %>% zapsmall()

comps_sin[1:50]
```

::: {.exam-points}
Routine mediante `reduce`. 
:::
```{r}
# Implementazione mediante reduce
sig_art <- sig_art %>% mutate(
  p_art_k = a0 + reduce(1:K, \(acc, k) {
    c <- cos_k(t, f_fund, k)
    s <- sin_k(t, f_fund, k)
    acc + comps_cos[k] * c/norm_ps(c) + comps_sin[k] * s/norm_ps(s)
  }, .init = rep(0, n()))
)

plot_ly() %>%
  add_lines(x = sig_art$t, y = sig_art$p_art, line = list(color = "blue"), name = "Originale") %>%
  add_lines(x = sig_art$t, y = sig_art$p_art_k, line = list(color = "red"), name = "Ricostruito") %>%
  layout(xaxis = list(title = "Tempo (s)"), yaxis = list(title = "Pressione (mmHg)"), title = "Ricostruzione del segnale")
```








