[
  {
    "objectID": "ex2.html",
    "href": "ex2.html",
    "title": "Esercitazione 2",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie."
  },
  {
    "objectID": "ex2.html#modulazione",
    "href": "ex2.html#modulazione",
    "title": "Esercitazione 2",
    "section": "2.1 Modulazione",
    "text": "2.1 Modulazione\n\n# Onda portante: carrier &lt;- cos(2 * pi * fp * t)\n# Aggiungiamo alla struttura associata alla misura il segnale modulato:\nym &lt;- ym %&gt;% mutate(\n    yn_m = (1 + m * ym$yn) * cos(2 * pi * fp * t),\n    fft_m = fft(yn_m),\n    intensity_m = Mod(fft_m) / length(t)*2,\n    phase_m = Arg(fft_m)/pi*180\n  )\n\nym %&gt;% pivot_longer(\n    cols = c(yn, yn_m)\n  ) %&gt;% mutate(\n    name = factor(name, levels = c(\"yn_m\", \"yn\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(\n    \"yn_m\" = \"Modulato\",\n    \"yn\" = \"Misurato\"\n  )) +\n  labs(x = \"Tempo (s)\", y = \"Segnale\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\n\nplot_ly() %&gt;%\n  add_bars(data = ym, x = ~f, y = ~intensity, name = \"Segnale\", marker = list(color = \"blue\")) %&gt;%\n  add_bars(x = r$f, y = r$intensity, name = \"Rumore\", marker = list(color = \"red\")) %&gt;%\n  add_bars(data = ym, x = ~f, y = ~intensity_m, name = \"Segnale Modulato\", marker = list(color = \"green\")) %&gt;%\n  layout(title = \"Spettro di Intensità\",\n       xaxis = list(title = \"Frequenza (Hz)\", range = c(0, 500), showgrid = TRUE),\n       yaxis = list(title = \"Intensità\", showgrid = TRUE),\n       legend = list(x = 0.25, y = 0.9))"
  },
  {
    "objectID": "ex2.html#esposizione-del-segnale-modulato-al-rumore",
    "href": "ex2.html#esposizione-del-segnale-modulato-al-rumore",
    "title": "Esercitazione 2",
    "section": "2.2 Esposizione del segnale modulato al rumore",
    "text": "2.2 Esposizione del segnale modulato al rumore\n\n# Effetto interferente sul segnale modulato:\nym &lt;- ym %&gt;% mutate(\n    yn_m_n = yn_m + r$y,\n    fft_m = fft(yn_m_n),\n    intensity_m = Mod(fft_m) / length(t)*2,\n    phase_m = Arg(fft_m)/pi*180\n  )\n\nplot_ly() %&gt;%\n  add_lines(data = ym, x = ~f, y = ~intensity_m, type = \"bar\", name = \"Segnale\", marker = list(color= \"blue\")) %&gt;%\n  layout(title = \"Spettro segnale modulato affetto da rumore\",\n       xaxis = list(title = \"Frequenza (Hz)\", range = c(0, 500), showgrid = TRUE),\n       yaxis = list(title = \"Intensità\", showgrid = TRUE))\n\n\n\n\n\n\nplot_ly() %&gt;%\n  add_lines(data = ym, x = ~t, y = ~yn_m, name = \"Segnale modulato\") %&gt;%\n  add_lines(data = ym, x = ~t, y = ~yn_m_n, name = \"Con effetto interferente\") %&gt;%\n  layout(title = \"Segnale modulato affetto da rumore\", \n         xaxis = list(title = \"Tempo (s)\"), \n         yaxis = list(title = \"Segnale\"))"
  },
  {
    "objectID": "ex2.html#eliminazione-del-rumore-interferente",
    "href": "ex2.html#eliminazione-del-rumore-interferente",
    "title": "Esercitazione 2",
    "section": "3.1 Eliminazione del rumore interferente",
    "text": "3.1 Eliminazione del rumore interferente\nOsservando lo spettro del segnale modulato esposto al rumore interferente, è evidente come le componenti di rumore siano separate da quelle del segnale modulato, che si trova ad alta frequenza. Pertanto, può essere implementato un filtro digitale passa-alto offline per selezionare solo quello modulato.\n\nFiltro passa-alto.\n\nInizialmente è stato scelto un filtro Butterworth, il cui ordine e frequenza di taglio sono stati selezionati a tentativi, affinché attenuassero il più possibile l’ultima componente di rumore a 135 Hz senza ridurre eccessivamente il segnale modulato.\n\nf_cutoff &lt;- 200\nflt.butter &lt;- butter(4, f_cutoff/(fc/2), type = \"high\")  # filtro Butterworth passa-alto\n\nggbodeplot_digital(flt.butter, fc, fmin = 1e1) + geom_vline(xintercept = f_cutoff, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- tibble(\n  t = ym$t,\n  yn = ym$yn,\n  yn_m = ym$yn_m,\n  yn_m_n = ym$yn_m_n,\n  yn_m_n.flt = signal::filtfilt(flt.butter, yn_m_n),   # estrae il segnale modulato\n  f = 0:(length(t)-1)/max(t),\n  fft = fft(yn_m_n.flt),\n  intensity = Mod(fft)/length(t)*2,\n  phase = Arg(fft)*180/pi\n) \n\nym.flt %&gt;% dplyr::filter(f &lt;= fc/2) %&gt;% plot_ly(x = ~f) %&gt;%\n  add_lines(y = ~intensity) %&gt;%\n  layout(xaxis = list(title=\"Frequenza (Hz)\"), yaxis=list(title=\"Intensità\"), title=\"Filtraggio del segnale modulato con filtro Butterworth\")\n\n\n\n\n\nTuttavia, nello spettro compare ancora una componente di rumore e il segnale in banda trasmessa risulta leggermente attenuato. Dunque, viene implementato un filtro di tipo Chebishev II, il quale a parità di ordine del Butterfly possiede una banda di transizione più ripida. Questo genere di filtro introdurrà un ripple in banda di stop, che però verrà attenuato mediante un filtraggio delle basse frequenze, che è richiesto per eliminare il rumore bianco. Nello specifico, a tentativi è stato scelto un taglio pari alla componente di più alta frequenza del rumore interferente.\n\nf_cutoff &lt;- max(pars_r$f)\nflt.cheby &lt;- cheby2(4, 20, f_cutoff/(fc/2), type = \"high\")  # N.B.: 20dB di riduzione del ripple in stop band\n\nggbodeplot_digital(flt.cheby, fc, fmin = 1e1) + geom_vline(xintercept = f_cutoff, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- ym.flt %&gt;% mutate(\n  yn_m_n.flt = signal::filtfilt(flt.cheby, yn_m_n),   # estrae il segnale modulato\n  f = 0:(length(t)-1)/max(t),\n  fft = fft(yn_m_n.flt),\n  intensity = Mod(fft)/length(t)*2,\n  phase = Arg(fft)*180/pi\n) \n\nym.flt %&gt;% dplyr::filter(f &lt;= fc/2) %&gt;% plot_ly(x = ~f) %&gt;%\n  add_lines(y = ~intensity) %&gt;%\n  layout(xaxis = list(title=\"Frequenza (Hz)\"), yaxis=list(title=\"Intensità\"), title=\"Filtraggio del segnale modulato con filtro Chebyshev II\")\n\n\n\n\n\nInfatti, ora lo spettro mostra il rumore essere quasi inesistente e il segnale trasmesso quasi privo di attenuazione.\n\nym.flt %&gt;% plot_ly(x = ~t) %&gt;%\n  add_lines(y = ~yn_m_n, name = \"Con rumore interferente\") %&gt;%\n  add_lines(y = ~yn_m, name = \"Modulato\") %&gt;%\n  add_lines(y = ~yn_m_n.flt, name = \"Filtrato\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"Segnale\"), title = \"Estrazione del segnale modulato\")\n\n\n\n\n\nA conferma del corretto procedimento di filtraggio è il fatto che il segnale ottenuto corrisponde a quello modulato prima dell’esposizione al rumore."
  },
  {
    "objectID": "ex2.html#demodulazione",
    "href": "ex2.html#demodulazione",
    "title": "Esercitazione 2",
    "section": "3.2 Demodulazione",
    "text": "3.2 Demodulazione\n\nDemodulazione.\n\nIl processo di demodulazione è quello che permette di separare il segnale misurato dalla portante. A tal fine, viene scelta la demodulazione sincrona [suggerimento ChatGPT], in cui il segnale modulato viene moltiplicato per un’armonica pura con stessa frequenza e fase della portante (per questo si chiama “sincrona”). Nello specifico, i passaggi da seguire sono i seguenti:\n\n:\n\n\\[\\begin{aligned}\ny_{mix} :&= y_{mod}(t) \\cdot \\cos(2\\pi f_p t) \\\\\n&= (1 + m y(t)) \\cos^2(2\\pi f_p t) \\\\\n&= (1+my(t))\\frac{1+\\cos(4\\pi f_p t)}{2} \\\\\n&= \\frac{1}2 (1+m y(t)) + \\frac{1}2 (1+my(t))\\cos(4 \\pi f_p t) .\n\\end{aligned}\\]\n\nFiltraggio passa-basso: il segnale ottenuto dal mixing è caratterizzato da una componente a bassa frequenza (pari al più a \\(f_{max}\\) del segnale misurato) ed una ad alta frequenza (pari a \\(2f_p\\)): \\[\nLP\\{y_{mix}\\}(f_{max} &lt; f_{cutoff} \\ll 2f_p) \\longrightarrow y_{flt} \\approx 1+my(t) .\n\\]\nRielaborazione matematica per ottenere il segnale misurato:\n\n\\[\n\\frac{1}m (y_{flt} - 1) = y(t) .\n\\]\nIn particolare, il filtro passa-basso permette anche di attenuare il ripple dal filtro Chebyshev e il rumore bianco.\n\nym.flt &lt;- ym.flt %&gt;% select(-fft, -intensity, -phase, -f) %&gt;% mutate(\n  y_mix = (2*yn_m_n.flt*cos(2*pi*fp*t) - 1)/m   # demodulazione + rielaborazione matematica\n)\n\n# Filtro passa-basso\n# Taglio al doppio della freq. max del segnale misurato\n# per far passare l'intero suo spettro\nf_cut2 &lt;- 2*max(pars_m$f)\nflt.butter.lp &lt;- butter(2, f_cut2/(fc/2))\n\nggbodeplot_digital(flt.butter.lp, fc, fmin = 1) + geom_vline(xintercept = f_cut2, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- ym.flt %&gt;% mutate(\n  y_flt2 = filtfilt(flt.butter.lp, y_mix)\n)\n\nym.flt %&gt;% plot_ly(x = ~t) %&gt;%\n  add_lines(y = ~yn_m_n.flt, name = \"Filtrato\") %&gt;%\n  add_lines(y = ~y_flt2, name = \"Demodulato\") %&gt;%\n  layout(xaxis = list(title=\"Tempo (s)\"), yaxis=list(title=\"Segnale\"), title = \"Demodulazione\")\n\n\n\n\n\n\nComparazione con la misura originale.\n\n\nym.flt %&gt;% pivot_longer(cols = c(\"yn\", \"y_flt2\")) %&gt;%\n  mutate(\n    name = factor(name, levels = c(\"yn\", \"y_flt2\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(yn = \"Originale\", y_flt2 = \"Demodulato\")) +\n  labs(x = \"Tempo (s)\", y = \"Segnale\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\nSi osservi come il processo di demodulazione ha permesso anche di filtrare il rumore."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Esercitazioni di esame",
    "section": "",
    "text": "Questo sito contiene la raccolta di esercitazioni da consegnare all’esame di Misure Industriali, del corso di Ingegneria Industriale, presso l’Università di Trento.\nLe esercitazioni fanno riferimento al sito relativo al corso di insegnamento.\npoi devo mettere le librerie in un htmle per vedere tutto formattata bene a codice\n\nQuesti riquadri servono a mettere in rilievo quando viene data risposta ai quesiti dell’esercitazione.\n\n\n1 Contenuti\n\nLibrerie:\n\ndig_signal_proc.R: funzioni relative al digital signal processing\ngraphics.R: funzioni relative alla formattazione della grafica\n\nEsercitazione 1 - Segnale di onda pressoria\nEsercitazione 2 - Modulaione di ampiezza"
  },
  {
    "objectID": "ex1.html",
    "href": "ex1.html",
    "title": "Esercitazione 1",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie.\nParametri di campionamento che verranno considerati nell’analisi:\n# Campionamento regolare\nfs &lt;- 1000      # freq. di campionamento\nTs &lt;- 1/fs      # periodo di campionamento"
  },
  {
    "objectID": "ex1.html#ricostruzione-mediante-serie-di-fourier",
    "href": "ex1.html#ricostruzione-mediante-serie-di-fourier",
    "title": "Esercitazione 1",
    "section": "1.1 Ricostruzione mediante serie di Fourier",
    "text": "1.1 Ricostruzione mediante serie di Fourier\nIl segnale viene ricostruito mediante le serie di Fourier, in cui l’\\(n\\)-esimo elemento vale:\n\\[\np[n] = a_0 + \\sum_{k = 1}^{K} a_k \\cos[2\\pi k f_0 \\, n] + \\sum_{k = 1}^{K} a_k \\sin[2\\pi k f_0  \\, n] ,\n\\]\ndove \\(f_0\\) è la frequenza fondamentale, \\(K\\) è il numero totale di componenti armoniche e \\(a_k, b_k\\) sono le \\(k\\)-esime componenti, risultato della scomposizione su basi orto-normali. Si osservi che la componente in DC non viene divisa per 2, perché è calcolata come la media del segnale, anziché il doppio della media (come da teoria della trasformata).\nLa \\(k\\)-esima componente avrà frequenza pari a \\(f_k = k f_0 = \\frac{k}{T_a}\\), dove \\(T_a = 10\\,\\mathrm{s}\\) è il tempo di acquisizione. Perciò, in virtù del Teorema di Nyquist-Shannon, deve valere la seguente disuguaglianza, per la quale si calcola la massima componente:\n\\[\nf_{max} = \\frac{k_{max}}{T_a} \\leq \\frac{f_s}2 \\Leftrightarrow k_{max} = \\frac{f_s T_a}{2} = 5000,\n\\] con \\(f_s = 1000\\,\\mathrm{Hz}\\) la frequenza di campionamento.\n\nRicostruzione segnale anche con i coseni.\n\n\na0 &lt;- mean(sig_art$p_art)\n\n# La componente DC è ortogonale alle basi seno e cose\n# Per evitare errori numerici, quest'ultima viene sottratta al segnale\np_art_osc &lt;- sig_art$p_art - a0\n\nK &lt;- 500 # massimo possibile: 5e3\nf_fund &lt;- 1/Ta\n\ncomps_cos &lt;- map_dbl(1:K, \\(k) {\n  c &lt;- cos_k(sig_art$t, f_fund, k)\n  p_art_osc %ps% c/norm_ps(c)\n}) %&gt;% zapsmall()\n\ncomps_sin &lt;- map_dbl(1:K, \\(k) {\n  s &lt;- sin_k(sig_art$t, f_fund, k)\n  p_art_osc %ps% s/norm_ps(s)\n}) %&gt;% zapsmall()\n\ncomps_sin[1:50]\n\n [1]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n [8]  0.000000  0.000000  9.340245  0.000000  0.000000  0.000000  0.000000\n[15]  0.000000  0.000000  0.000000  0.000000  0.000000  3.153407  0.000000\n[22]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n[29]  0.000000  3.164646  0.000000  0.000000  0.000000  0.000000  0.000000\n[36]  0.000000  0.000000  0.000000  0.000000  1.965583  0.000000  0.000000\n[43]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n[50] -0.061118\n\n\n\nRoutine mediante reduce.\n\n\n# Implementazione mediante reduce\nsig_art &lt;- sig_art %&gt;% mutate(\n  p_art_k = a0 + reduce(1:K, \\(acc, k) {\n    c &lt;- cos_k(t, f_fund, k)\n    s &lt;- sin_k(t, f_fund, k)\n    acc + comps_cos[k] * c/norm_ps(c) + comps_sin[k] * s/norm_ps(s)\n  }, .init = rep(0, n()))\n)\n\nplot_ly() %&gt;%\n  add_lines(x = sig_art$t, y = sig_art$p_art, name = \"Originale\") %&gt;%\n  add_lines(x = sig_art$t, y = sig_art$p_art_k, name = \"Ricostruito\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"Pressione (mmHg)\"), title = \"Ricostruzione del segnale\")"
  },
  {
    "objectID": "ex1.html#analisi-statica",
    "href": "ex1.html#analisi-statica",
    "title": "Esercitazione 1",
    "section": "3.1 Analisi statica",
    "text": "3.1 Analisi statica\n\nAnalisi statica dei residui.\n\n\n# Traslo il tempo a 0: fa comodo partire da lì\np.flt_5Hz &lt;- p.flt_5Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;%  \n  mutate(eps = p_k - p_flt)\n\np.flt_2Hz &lt;- p.flt_2Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;% \n  mutate(eps = p_k - p_flt)\n\np.flt_7Hz &lt;- p.flt_7Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;% \n  mutate(eps = p_k - p_flt)\n\nbind_rows(\n  p.flt_2Hz %&gt;% mutate(case = \"2 Hz\"),\n  p.flt_5Hz %&gt;% mutate(case = \"5 Hz\"),\n  p.flt_7Hz %&gt;% mutate(case = \"7 Hz\")\n) %&gt;% pivot_longer(\n  cols = c(p_k, p_flt)\n) %&gt;% mutate(\n    name = factor(name, levels = c(\"p_k\", \"p_flt\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(\n    \"p_k\" = \"Ricostruito\",\n    \"p_flt\" = \"Filtrato\"\n  )) +\n  facet_wrap(~ case, ncol = 1, scales = \"free_x\") +\n  labs(x = \"Tempo (s)\", y = \"Pressione (mmHg)\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\n\nbind_rows(\n  p.flt_2Hz %&gt;% mutate(caso = \"2 Hz\"),\n  p.flt_5Hz %&gt;% mutate(caso = \"5 Hz\"),\n  p.flt_7Hz %&gt;% mutate(caso = \"7 Hz\")\n) %&gt;% ggplot(aes(x = t, y = eps, colour = caso)) +\n  geom_point(size = 0.6, alpha = 0.6) +\n  labs(x = \"Tempo (s)\", y = \"Residui (mmHg)\", colour = latex2exp::TeX(\"$f_c\"))\n\n\n\n\n\n\n\n\nDai grafici soprastanti è evidente come anticipare il taglio distorga il segnale da quello di riferimento."
  },
  {
    "objectID": "ex1.html#analisi-in-frequenza",
    "href": "ex1.html#analisi-in-frequenza",
    "title": "Esercitazione 1",
    "section": "3.2 Analisi in frequenza",
    "text": "3.2 Analisi in frequenza\n\nAnalisi in frequenza dei residui.\n\n\n# Funzione per automatizzare il calcolo dello spettro\ncompute_fft &lt;- function(df, Ta, N, name_sig, monolateral = TRUE) {\n  \n  df &lt;- df %&gt;% mutate(\n    f = n/Ta,\n    fft = fft({{ name_sig }}),\n    mod = ifelse(monolateral, (2-(f==0)), 1) * Mod(fft) / length(n),\n    phase = Arg(fft)/pi*180\n  )\n  \n  if(monolateral)\n    return(df %&gt;% slice_head(n = floor(N/2)))\n  \n  df\n}\n\n\n# Nuovo tempo di campionamento (a causa dell'eliminazione delle code)\nTa &lt;- max(p.flt_2Hz$t) + 1/fs\nN &lt;- length(p.flt_2Hz$n)\n\n# Spettro dei segnali senza la componenti a f=0\np.flt_2Hz.fft &lt;- compute_fft(p.flt_2Hz, Ta, N, eps) %&gt;% slice(-1)\np.flt_5Hz.fft &lt;- compute_fft(p.flt_5Hz, Ta, N, eps) %&gt;% slice(-1)\np.flt_7Hz.fft &lt;- compute_fft(p.flt_7Hz, Ta, N, eps) %&gt;% slice(-1)\n\nbind_rows(\n  p.flt_2Hz.fft %&gt;% mutate(caso = \"2 Hz\"),\n  p.flt_5Hz.fft %&gt;% mutate(caso = \"5 Hz\"),\n  p.flt_7Hz.fft %&gt;% mutate(caso = \"7 Hz\")\n) %&gt;% dplyr::filter(f &lt; 50) %&gt;% \n  ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(angle = pi/2, y=0, radius = mod), linewidth = 0.2, colour = \"#F8766D\") +\n  geom_point(colour = \"#F8766D\") +\n  facet_wrap(~ caso, ncol = 1, scales = \"free_x\") +\n  labs(\n    x = \"Frequenza (Hz)\",\n    y = \"Ampiezza Residui (mmHg)\",\n    title = \"Spettri dei segnali filtrati\"\n  )\n\n\n\n\n\n\n\n\n\ntmp &lt;- list(fc_2 = p.flt_2Hz, fc_5 = p.flt_5Hz, fc_7 = p.flt_7Hz)\n\nstats &lt;-  tibble(\n  fc = c(\"2 Hz\", \"5 Hz\", \"7 Hz\"),\n  mean = map_dbl(tmp, ~ mean(.x$eps)),\n  sd = map_dbl(tmp, ~ sd(.x$eps))\n)\n\nknitr::kable(stats, digits = 2, caption = \"Statistiche dei residui\")\n\n\nStatistiche dei residui\n\n\nfc\nmean\nsd\n\n\n\n\n2 Hz\n0.14\n6.01\n\n\n5 Hz\n0.04\n1.73\n\n\n7 Hz\n0.02\n0.71\n\n\n\n\n\nAnche osservando lo spettro dei residui è chiaro come avere una frequenza di taglio troppo bassa porti ad allontanarsi dall’andamento nominale. Infatti la dispersione dei residui tende ad aumentare (si guardi al valore di deviazione standard).\n\nFrequenza di taglio finale.\n\nDunque, per concludere, da un lato non è opportuno filtrare troppo tardi, poiché non verrebbe filtrato sufficientemente il rumore del segnale. Dall’altra, anticipare eccessivamente il taglio implica una distorsione dal segnale di riferimento, di cui un buon indicatore è la deviazione standard dei residui; questo fenomeno è dovuto a una soverchiante attenuazione di componenti in frequenza, magari proprie del segnale nominale stesso. Quindi, sulla base delle precedenti osservazioni, si sceglie una frequenza di taglio pari a \\(f_c = 7\\,\\mathrm{Hz}\\), ritenuta la più approssimativa del segnale ricostruito con Fourier."
  }
]