[
  {
    "objectID": "ex5.html",
    "href": "ex5.html",
    "title": "Esercitazione 5",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie.\n\n1 Funzioni\n\n# FUNZIONE: Generazione segnale sinusoidale con diverse armoniche\nsignal &lt;- function(t, pars, rad = FALSE) { \n  stopifnot(is.data.frame(pars))\n  with(pars, {\n    if (!rad) {\n      phi &lt;- phi/180*pi\n      f &lt;- 2*pi*f\n    }\n    map_dbl(t, \\(t) sum( map_vec(seq_along(w) , \\(i) w[i]*cos(t*f[i] + phi[i] ))))\n  })\n}\n\n\n\n2 Segnale d’ingresso\n\nf0 &lt;- 10\n\n# Provare con un'armonica pura\n# pars &lt;- tibble(\n#   w = c(1),\n#   f = c(f0),  # 1 funziona\n#   phi = c(0)\n# )\n\n# Provare con tante armoniche\npars &lt;- tibble(\n  w = c(1, 0.1, 0.3),\n  f = c(15, 20, 45),\n  phi = c(0, 0, 0)\n)\n\nN &lt;- 1000   # dimensione del campione\nfs &lt;- 1000  # freq. di campionamento\n\ns &lt;- tibble(\n  t = 0:N / fs, # 1 kHz di frequenza di campionamento\n  u = signal(t, pars), \n  u_n = u + rnorm(length(t), 0, pars$w[1] / 10)\n)\n\n\nspectrum_fft(s, fs, \"u_n\") %&gt;% ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(y=0, radius = mod, angle = pi/2)) +\n  geom_point() +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\")\n\n\n\n\n\n\n\n\n\n\n3 FdT del sistema di isolamento\n\nM &lt;- 10\nK &lt;- 1000\nC &lt;- 50\n\n# Frequenza naturale:\nfn &lt;- 1/(2*pi) * sqrt(K/M)\n\nnum &lt;- c(C, K)\nden &lt;- c(M, C, K)\n\nH &lt;- tf(num, den)\n\nggbodeplot_continous(H, fs, fmin=0.1, fmax=100) +\n  geom_vline(xintercept=c(1, sqrt(2)) * fn, color=\"red\", linetype=2) +\n  labs(title=paste(\n    \"Natural frequency:\", round(fn, 2), \"Hz\",\n    \" - Isolation: &gt;\", round(sqrt(2)*fn, 2), \"Hz\"))\n\n\n\n\n\n\n\n\n\n\n4 Simulazione dell’uscita\n\noutput &lt;- lsim(H, s$u_n, s$t)\ns &lt;- s %&gt;% \n  mutate(\n    # Simulazione dell'uscita\n    y = output$y[1,]\n  )\n\n# Grafici\nplot_ly() %&gt;%\n  add_lines(x = s$t, y = s$u_n, name = \"Input\") %&gt;%\n  add_lines(x = s$t, y = s$y, name = \"Output\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"\"), title = \"Input & Output\")\n\n\n\n\n\n\n\n5 Ricostruzione dell’ingresso\n\nStima dell’ingresso a partire da uscita del sistema e da modulo e fase della FdT.\n\nR è in grado di operare nel domino complesso, perciò viene effettuata la compensazione dell’ingresso nel dominio della frequenza, come in Esercitazione 4. Nello specifico, mediante la funzione di libreria dyn_compensation vengono essenzialmente svolti i segueni passaggi, presupponendo un’opportuno segnale d’uscita passatogli come parametro:\n\neventuale padding, impostato dall’utente, per garantire la completa periodicità del segnale;\ncalcolo dalla FFT del segnale d’uscita e valutazione numerica della risposta in frequenza della FdT;\ninversione della caratteristica dinamica;\nFFT inversa che calcola l’ingresso nel dominio del tempo.\n\nPer effettuare la compensazione, è bene prendere atto che l’FdT inversa è un passa-alto:\n\n\n[1] \"TFCHK: Transfer function may not be proper and may lead to errors. Num &gt; Den\"\n\n\n\n\n\n\n\n\n\nSulla base dei diagrammi di bode ed osservando lo spettro dell’uscita che segue, è evidente che le componenti oltre i \\(2.25\\,\\mathrm{Hz}\\) verranno amplificate.\n\ny &lt;- s %&gt;% dplyr::select(t, y) \n\nspectrum_fft(y, name_sig = \"y\") %&gt;% dplyr::filter(f &lt; 100) %&gt;%\n  ggplot(aes(f, mod)) +\n  geom_spoke(aes(y = 0, radius = mod, angle = pi/2), color = \"#56B4E9\") +\n  geom_point(color = \"#56B4E9\") +\n  geom_vline(xintercept = sqrt(2)*fn, linetype = 2, color = \"red\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\", title = \"Spettro dell'output\")\n\n\n\n\n\n\n\n\nA questo punto viene effettuata la compensazione:\n\n# Compensazione dell'uscita\nu &lt;- s %&gt;% select(t, u, u_n) %&gt;%\n  mutate(\n    u_comp = dyn_compensation(y, H, name_sig = \"y\")$u\n  )\n\n\n\n\n\n\n\nCome anticipato l’inversione della FdT comporta la ricostruzione di un segnale abbastanza rumoroso. Per comprendere il tipo di rumore e quali componenti lo costituiscano si osserva lo spettro del segnale.\n\nspectrum_fft(u, name_sig = \"u_comp\") %&gt;% \n  ggplot(aes(f, mod)) +\n  geom_spoke(aes(y = 0, radius = mod, angle = pi/2), color = \"#F8766D\") +\n  geom_point(color = \"#F8766D\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\", title = \"Spettro dell'input compensato\")\n\n\n\n\n\n\n\n\nIl segnale compensato presenta un fondo spettrale diffuso e privo di struttura armonica evidente, compatibile con un rumore di tipo bianco. Pertanto, ai fini di eliminare quest’ultimo e ricostruire il segnale utile come somma delle sole componenti armoniche dominanti, viene realizzata una maschera in frequenza che annulla le componenti associate al fondo spettrale.\n\nN &lt;- nrow(u)\nk &lt;- 0:(N-1)\n\n# La soglia per selezionare le componenti predominanti\n# viene individuata visivamente dallo spettro\nthreashold &lt;- 0.04\n\n\nu_spectrum &lt;- tibble(\n    f = ifelse(k &lt;= N/2, k, k-N) * fs/N,\n    U = fft(u$u_comp),\n    mask = Mod(U)/N &gt; threashold,        # vettore di booleani\n    U_filtered = U*mask\n)\n\nu_spectrum %&gt;% dplyr::filter(f&gt;=0) %&gt;%\n  mutate(mod = 2*Mod(U_filtered)/N) %&gt;% \n  ggplot(aes(f, mod)) + \n  geom_spoke(aes(y = 0, radius = mod, angle = pi/2), color = \"#F8766D\") +\n  geom_point(color = \"#F8766D\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\", title = \"Spettro del input mascherato\")\n\n\n\n\n\n\n\n\nNota: la componente DC viene processata dalla maschera perché visivamente si vede (e si sa a priori in questo caso) che il segnale di ingresso a media nulla. In generale sarebbe buona pratica sottrarre tale componente.\n\n# Segnale nel tempo mediante FFT^-1\nu &lt;- u %&gt;% mutate(\n    u_new = Re(fft(u_spectrum$U_filtered, inverse = T))/N\n  )\n\n\n\n\n\n\n\nSi conclude visivamente come adesso il segnale compensato tenda ad assomigliare molto bene a quello ideale, peraltro con nessuna particolare discrepanza sulle code. Si può quantificare la differenza tra le due curve tramite i residui: \\[\n\\varepsilon = u_{id} - u_{comp} .\n\\]\nCome era prevedibile la componente di rumore bianco è pressoché irrisoria rispetto alle armoniche pure. Comunque è un buon algoritmo per eliminare il rumore bianco.\n\n# Calcolo i residui tra ideale e ricostruito\neps &lt;- tibble(\n  t = u$t,\n  e = u$u - u$u_new\n)\n\neps %&gt;% ggplot(aes(x = t, y = e)) + geom_point()"
  },
  {
    "objectID": "ex3.html",
    "href": "ex3.html",
    "title": "Esercitazione 3",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie.\n\n1 Funzione di trasferimento e risposta al gradino\n\nFunzione di trasferimento e risposta al gradino.\n\nIl principio alla base per ricavare la funzione di trasferimento del sistema è il bilancio delle potenze termiche scambiate:\n\\[\nm c \\frac{d}{dt} T(t) = \\alpha A(T_{amb}(t)-T(t)) \\overset{\\mathcal{F}}{\\longrightarrow} mc \\, j\\omega T(j\\omega) =\\alpha A (T_{amb}(j\\omega) - T(j\\omega)).\n\\]\nPerciò, bilanciando la potenza scambiata tra sonda (uscita del sistema) e guaina, si ottiene:\n\\[\\begin{aligned}\nm_s c_s \\, j\\omega T_s(j\\omega) &= \\alpha_{gs} A_{gs} (T_{g}(j\\omega) - T_s(j\\omega)) \\\\\n\\Leftrightarrow \\frac{T_s(j\\omega)}{T_g(j\\omega)} &= \\frac{1}{\\tau_1 \\, j\\omega + 1} ,\n\\end{aligned}\\]\ndove \\(\\tau_2 = \\frac{M_s c_s}{\\alpha_{gs} A_{gs}}\\).\nMediante gli stessi procedimenti, si può esprimere anche la potenza scambiata tra il misurando (input del sistema) e la guaina:\n\\[\\begin{aligned}\nm_g c_g \\, j\\omega T_g(j\\omega) &= \\alpha_{mg} A_{gs} (T_{m}(j\\omega) - T_g(j\\omega)) \\\\\n\\Leftrightarrow \\frac{T_g(j\\omega)}{T_m(j\\omega)} &= \\frac{1}{\\tau_2 \\, j\\omega + 1} ,\n\\end{aligned}\\]\ndove dove \\(\\tau_1 = \\frac{M_g c_g}{\\alpha_{mg} A_{mg}}\\).\nPertanto, esprimendo \\(T_g\\) in funzione di \\(T_m\\), si ricava la funzione di risposta in frequenza tra misura (sonda) e misurando:\n\\[\nH(j\\omega) = \\frac{1}{\\tau_1 \\tau_2 (j \\omega)^2 + (\\tau_1 + \\tau_2)j\\omega + 1}.\n\\]\nRiguardo alla risposta allo scalino da \\(T_i\\) a \\(T_f\\) nelle condizioni di \\(\\tau_1 &gt; \\tau_2\\), si modella il gradino come segue, traslato di \\(T_i\\):\n\\[\\begin{aligned}\nT_m(t) = T_i + (T_f - T_i)\\,\\text{sca}(t) &\\overset{T_i = \\text{cost}}{\\Leftrightarrow} \\vartheta_m(t) := T_m(t) - T_i = (T_f - T_i)\\,\\text{sca}(t) \\\\\n&\\overset{\\mathcal{L}}{\\longrightarrow} \\Theta_m(s) = (T_f - T_i)\\frac{1}s .\n\\end{aligned}\\]\nSi definisce anche l’uscita traslata di \\(T_i\\):\n\\[\n\\vartheta_s(t) := T_s(t) - T_i \\overset{\\mathcal{L}}{\\longrightarrow} \\Theta_s(s).\n\\]\nIn virtù della natura LTI del sistema, la risposta allo scalino nel dominio della frequenza è pari a\n\\[\n\\Theta_s(s) = H(s) \\cdot (T_f - T_i)\\frac{1}s.\n\\]\nMediante la scomposizione per fratti semplici e poi anti-trasformando, si ottiene la risposta nel dominio nel tempo:\n\\[\nT_s(t) = T_f + (T_i+T_f) \\cdot \\left( \\frac{\\tau_1}{\\tau_1 - \\tau_2} e^{-\\frac{t}{\\tau_1}} - \\frac{\\tau_2}{\\tau_1 - \\tau_2} e^{-\\frac{t}{\\tau_2}} \\right) .\n\\]\n\n\n2 Segnale campionato\nIl set di dati è disponibile a questo link.\n\ndf &lt;- read.table(\"datiPT100_2005Taratura.txt\", header=FALSE, sep=\"\\t\", dec=\",\", stringsAsFactors=FALSE)\ncolnames(df) &lt;- c(\"t\", \"temp\", \"temp_f\")\n\ndf &lt;- df %&gt;% dplyr::filter(t &gt;= 150) %&gt;% select(-temp_f) %&gt;%\n  mutate(t = t - 150)\n\ndf %&gt;% plot_ly(x = ~t, y = ~temp) %&gt;%\n  add_lines() %&gt;% \n  layout(xaxis = list(title=\"Tempo (s)\"), yaxis = list(title=\"Temperatura (°C)\"), title=\"Segnale di temperatura campionato\")\n\n\n\n\n\n\n# Verificato campionamento regolare con media e sd\nfs &lt;- 1/(df$t[2]-df$t[1]) # freq. di campionamento\nTa &lt;- max(df$t) # tempo di acquisizione: primo istante a 0 sec\n\nParametri di campionamento (regolare):\n\n\\(f_s =5.99\\,\\mathrm{Hz}\\)\n\\(T_a =244.67\\,\\mathrm{s}\\)\n\n\n\n3 Taratura costanti \\(\\tau_1\\) e \\(\\tau_2\\)\n\nRegressione sulle sole costanti di tempo.\n\n\nt0 &lt;- 28                        # soglia temporale tra plateau e transizione\nTi &lt;- mean(df$temp[df$t &lt; t0])\nTf &lt;- 82                        # attribuito visivamente\n\n# Modello fisico: risposta allo scalino\ntemperature &lt;- function(t, t0, Ti, Tf, tau1, tau2) {\n  ifelse(\n    t &lt; t0,\n    Ti,\n    Tf + (Ti-Tf)*(\n      tau1/(tau1-tau2)*exp( - (t-t0)/tau1 ) -\n      tau2/(tau1-tau2)*exp( - (t-t0)/tau2 )\n    )\n  )\n}\n\ndf.nls &lt;- nls(temp ~ temperature(t, t0, Ti, Tf, tau1, tau2),\n              data = df, start = list(tau1 = 30, tau2=25)\n            )\nsummary(df.nls)\n\n\nFormula: temp ~ temperature(t, t0, Ti, Tf, tau1, tau2)\n\nParameters:\n     Estimate Std. Error t value Pr(&gt;|t|)    \ntau1 31.41414    0.06063  518.10   &lt;2e-16 ***\ntau2  0.86715    0.04374   19.83   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4801 on 1467 degrees of freedom\n\nNumber of iterations to convergence: 9 \nAchieved convergence tolerance: 4.686e-06\n\n\n\ndf &lt;- df %&gt;% add_predictions(df.nls) %&gt;% add_residuals(df.nls)\n\np1 &lt;- df %&gt;% ggplot(aes(x = t)) +\n  geom_line(aes(y = temp)) +\n  geom_line(aes( y = pred), color = \"red\") +\n  labs(x=\"Tempo (s)\", y=\"Temperatura (°C)\")\n\np2 &lt;- df %&gt;% ggplot(aes(x = t, y = resid)) +\n  geom_point() +\n  geom_vline(xintercept = as.numeric(coef(df.nls)[1]), color = \"orange\", linetype = 2) +\n  labs(x=\"Tempo (s)\", y=\"Residui (°C)\")\n\np1+p2\n\n\n\n\n\n\n\n\nOsservando i residui, è evidente un pattern di questi durante la fase di transizione che suggerisce un underfitting dei dati. Questo potrebbe essere sintomo che il modello fisico ipotizzato non sia adeguato. Peraltro, i parametri regrediti suggeriscono un comportamento predominante dalla costante di tempo \\(\\tau_1\\).\nTuttavia, graficamente è chiaro come la regressione nls segua bene le misure sperimentali e comunque si parla di una dispersione dei residui di circa \\(\\pm1 \\,\\mathrm{°C}\\).\n\n\n4 Taratura su tutti i parametri\n\nRegressione su tutti i parametri.\n\n\nparams &lt;- list(t0 = t0,\n               Ti = Ti,\n               Tf = Tf,\n               tau1 = as.numeric(coef(df.nls)[1]),\n               tau2 = as.numeric(coef(df.nls)[2])\n            )\n\ndf.nls2 &lt;- nls(temp ~ temperature(t, t0, Ti, Tf, tau1, tau2),\n               data = df, start = params)\nsummary(df.nls2)\n\n\nFormula: temp ~ temperature(t, t0, Ti, Tf, tau1, tau2)\n\nParameters:\n     Estimate Std. Error t value Pr(&gt;|t|)    \nt0   24.89962    0.13417  185.58   &lt;2e-16 ***\nTi   28.12231    0.03563  789.33   &lt;2e-16 ***\nTf   81.80832    0.01983 4124.48   &lt;2e-16 ***\ntau1 30.08639    0.10480  287.10   &lt;2e-16 ***\ntau2  4.71385    0.16979   27.76   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4449 on 1464 degrees of freedom\n\nNumber of iterations to convergence: 12 \nAchieved convergence tolerance: 5.334e-06\n\n\n\ndf &lt;- df %&gt;% add_predictions(df.nls2) %&gt;% add_residuals(df.nls2)\n\np1 &lt;- df %&gt;% ggplot(aes(x = t)) +\n  geom_line(aes(y = temp)) +\n  geom_line(aes( y = pred), color = \"red\") +\n  labs(x=\"Tempo (s)\", y=\"Temperatura (°C)\")\n\np2 &lt;- df %&gt;% ggplot(aes(x = t, y = resid)) +\n  geom_point() +\n  geom_vline(xintercept = as.numeric(coef(df.nls2)[1]), color = \"orange\", linetype = 2) +\n  labs(x=\"Tempo (s)\", y=\"Residui (°C)\")\n\np1+p2\n\n\n\n\n\n\n\n\nAnche in questo caso i residui continuano a mostrare un determinato andamento nella fase di transizione, ma visivamente la regressione si ben adatta alle misure sperimentali.\n\n\n5 Intervallo di confidenza dei parametri\n\nIntervallo di confidenza dei parametri mediante bootstrap.\n\nL’intervallo di confidenza (IC) viene calcolato al \\(95\\%\\): ossia è quell’intervallo al quale i parametri regrediti appartengono con tale probabilità.\n\n# Funzione che calcola i parametri di nls ad ogni ripetizione \n# per questa ragione sono delle statistiche\nstats &lt;- function(temp, data) {\n  fit &lt;- nls(temp ~ temperature(t, t0, Ti, Tf, tau1, tau2), \n             data = data, start = params)\n  return(fit$m$getPars())\n}\n\n# Bootstrap NON parametrico (con reinserimento di default)\ndf.b &lt;- boot(df, \\(x,i) stats(x[i, \"temp\"], x[i,]), R=10^4)\n\ndf.b\n\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = df, statistic = function(x, i) stats(x[i, \"temp\"], \n    x[i, ]), R = 10^4)\n\n\nBootstrap Statistics :\n     original        bias    std. error\nt1* 24.899622 -0.0187812531  0.30306764\nt2* 28.122310  0.0001920826  0.03677436\nt3* 81.808320 -0.0010426419  0.02429363\nt4* 30.086388 -0.0155241307  0.16449922\nt5*  4.713854  0.0296018435  0.39027614\n\n\nÈ verificato che le stime regredite coincidono con la regressione precedente, per cui si accetta il calcolo senza ulteriori dimostrazioni (e.g. un grafico QQ di ciascun parametro per capire se il numero di ripetizioni \\(R\\) è adeguato).\n\n# Intervallo di confidenza al 95% (metodo percentile)\nci &lt;- list(\n  t0 = boot.ci(df.b, type = \"perc\", index = 1)$percent[4:5],\n  Ti = boot.ci(df.b, type = \"perc\", index = 2)$percent[4:5],\n  Tf = boot.ci(df.b, type = \"perc\", index = 3)$percent[4:5],\n  tau1 = boot.ci(df.b, type = \"perc\", index = 4)$percent[4:5],\n  tau2 = boot.ci(df.b, type = \"perc\", index = 5)$percent[4:5]\n)\n\nGraficando l’IC, si mostra quanto sia incerta la stima della curva regredita.\nInteressanti sono gli IC relativi a \\(t_0, T_i\\) e \\(T_f\\).\n\n\n\n\n\n\n\n\n\nMentre su tutta la curva, combinando i diversi IC, si ottiene:\n\n# Funzione che calcola l'estremo alto o basso dell'IC\n# per ogni possibile combinazione degli estremi di IC\n# di ciascun parametro\nf_conf &lt;- function(t, temperature, ci, upper=TRUE) {\n  df &lt;- expand.grid(ci)       # ogni possibile combinazione di IC\n  df$temp &lt;- with(df, temperature(t, t0, Ti, Tf, tau1, tau2))\n  ifelse(upper, max(df$temp), min(df$temp))\n}\n\ndf %&gt;% mutate(\n  lower = map_dbl(t, ~f_conf(., temperature, ci, upper=FALSE)),\n  upper = map_dbl(t, ~f_conf(., temperature, ci))\n) %&gt;% ggplot(aes(x=t)) +\n  geom_ribbon(aes(ymin = lower, ymax = upper), fill=\"blue\", alpha=.5) +\n  geom_line(aes(y=temp)) +\n  geom_line(aes(y=pred), color=\"red\") +\n  labs(x=\"Tempo (s)\", y=\"Temperatura (°C)\")\n\n\n\n\n\n\n\n\nSi osserva come l’incertezza nella fase di transizione risulti più ampia, verosimilmente riconducibile alla stima di \\(\\tau_1\\) e \\(\\tau_2\\). Tale comportamento può indicare una parziale inadeguatezza del modello fisico adottato oppure una difficoltà di nls nel raggiungere una soluzione ottimale."
  },
  {
    "objectID": "ex1.html",
    "href": "ex1.html",
    "title": "Esercitazione 1",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie.\nParametri di campionamento che verranno considerati nell’analisi:\n# Campionamento regolare\nfs &lt;- 1000      # freq. di campionamento\nTs &lt;- 1/fs      # periodo di campionamento"
  },
  {
    "objectID": "ex1.html#ricostruzione-mediante-serie-di-fourier",
    "href": "ex1.html#ricostruzione-mediante-serie-di-fourier",
    "title": "Esercitazione 1",
    "section": "1.1 Ricostruzione mediante serie di Fourier",
    "text": "1.1 Ricostruzione mediante serie di Fourier\nIl segnale viene ricostruito mediante le serie di Fourier, in cui l’\\(n\\)-esimo elemento vale:\n\\[\np[n] = a_0 + \\sum_{k = 1}^{K} a_k \\cos[2\\pi k f_0 \\, n] + \\sum_{k = 1}^{K} a_k \\sin[2\\pi k f_0  \\, n] ,\n\\]\ndove \\(f_0\\) è la frequenza fondamentale, \\(K\\) è il numero totale di componenti armoniche e \\(a_k, b_k\\) sono le \\(k\\)-esime componenti, risultato della scomposizione su basi orto-normali. Si osservi che la componente in DC non viene divisa per 2, perché è calcolata come la media del segnale, anziché il doppio della media (come da teoria della trasformata).\nLa \\(k\\)-esima componente avrà frequenza pari a \\(f_k = k f_0 = \\frac{k}{T_a}\\), dove \\(T_a = 10\\,\\mathrm{s}\\) è il tempo di acquisizione. Perciò, in virtù del Teorema di Nyquist-Shannon, deve valere la seguente disuguaglianza, per la quale si calcola la massima componente:\n\\[\nf_{max} = \\frac{k_{max}}{T_a} \\leq \\frac{f_s}2 \\Leftrightarrow k_{max} = \\frac{f_s T_a}{2} = 5000,\n\\] con \\(f_s = 1000\\,\\mathrm{Hz}\\) la frequenza di campionamento.\n\nRicostruzione segnale anche con i coseni.\n\n\na0 &lt;- mean(sig_art$p_art)\n\n# La componente DC è ortogonale alle basi seno e cose\n# Per evitare errori numerici, quest'ultima viene sottratta al segnale\np_art_osc &lt;- sig_art$p_art - a0\n\nK &lt;- 500 # massimo possibile: 5e3\nf_fund &lt;- 1/Ta\n\ncomps_cos &lt;- map_dbl(1:K, \\(k) {\n  c &lt;- cos_k(sig_art$t, f_fund, k)\n  p_art_osc %ps% c/norm_ps(c)\n}) %&gt;% zapsmall()\n\ncomps_sin &lt;- map_dbl(1:K, \\(k) {\n  s &lt;- sin_k(sig_art$t, f_fund, k)\n  p_art_osc %ps% s/norm_ps(s)\n}) %&gt;% zapsmall()\n\ncomps_sin[1:50]\n\n [1]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n [8]  0.000000  0.000000  9.340245  0.000000  0.000000  0.000000  0.000000\n[15]  0.000000  0.000000  0.000000  0.000000  0.000000  3.153407  0.000000\n[22]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n[29]  0.000000  3.164646  0.000000  0.000000  0.000000  0.000000  0.000000\n[36]  0.000000  0.000000  0.000000  0.000000  1.965583  0.000000  0.000000\n[43]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n[50] -0.061118\n\n\n\nRoutine mediante reduce.\n\n\n# Implementazione mediante reduce\nsig_art &lt;- sig_art %&gt;% mutate(\n  p_art_k = a0 + reduce(1:K, \\(acc, k) {\n    c &lt;- cos_k(t, f_fund, k)\n    s &lt;- sin_k(t, f_fund, k)\n    acc + comps_cos[k] * c/norm_ps(c) + comps_sin[k] * s/norm_ps(s)\n  }, .init = rep(0, n()))\n)\n\nplot_ly() %&gt;%\n  add_lines(x = sig_art$t, y = sig_art$p_art, name = \"Originale\") %&gt;%\n  add_lines(x = sig_art$t, y = sig_art$p_art_k, name = \"Ricostruito\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"Pressione (mmHg)\"), title = \"Ricostruzione del segnale\")"
  },
  {
    "objectID": "ex1.html#analisi-statica",
    "href": "ex1.html#analisi-statica",
    "title": "Esercitazione 1",
    "section": "3.1 Analisi statica",
    "text": "3.1 Analisi statica\n\nAnalisi statica dei residui.\n\n\n# Traslo il tempo a 0: fa comodo partire da lì\np.flt_5Hz &lt;- p.flt_5Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;%  \n  mutate(eps = p_k - p_flt)\n\np.flt_2Hz &lt;- p.flt_2Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;% \n  mutate(eps = p_k - p_flt)\n\np.flt_7Hz &lt;- p.flt_7Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;% \n  mutate(eps = p_k - p_flt)\n\nbind_rows(\n  p.flt_2Hz %&gt;% mutate(case = \"2 Hz\"),\n  p.flt_5Hz %&gt;% mutate(case = \"5 Hz\"),\n  p.flt_7Hz %&gt;% mutate(case = \"7 Hz\")\n) %&gt;% pivot_longer(\n  cols = c(p_k, p_flt)\n) %&gt;% mutate(\n    name = factor(name, levels = c(\"p_k\", \"p_flt\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(\n    \"p_k\" = \"Ricostruito\",\n    \"p_flt\" = \"Filtrato\"\n  )) +\n  facet_wrap(~ case, ncol = 1, scales = \"free_x\") +\n  labs(x = \"Tempo (s)\", y = \"Pressione (mmHg)\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\n\nbind_rows(\n  p.flt_2Hz %&gt;% mutate(caso = \"2 Hz\"),\n  p.flt_5Hz %&gt;% mutate(caso = \"5 Hz\"),\n  p.flt_7Hz %&gt;% mutate(caso = \"7 Hz\")\n) %&gt;% ggplot(aes(x = t, y = eps, colour = caso)) +\n  geom_point(size = 0.6, alpha = 0.6) +\n  labs(x = \"Tempo (s)\", y = \"Residui (mmHg)\", colour = latex2exp::TeX(\"$f_c\"))\n\n\n\n\n\n\n\n\nDai grafici soprastanti è evidente come anticipare il taglio distorga il segnale da quello di riferimento."
  },
  {
    "objectID": "ex1.html#analisi-in-frequenza",
    "href": "ex1.html#analisi-in-frequenza",
    "title": "Esercitazione 1",
    "section": "3.2 Analisi in frequenza",
    "text": "3.2 Analisi in frequenza\n\nAnalisi in frequenza dei residui.\n\n\n# Funzione per automatizzare il calcolo dello spettro\ncompute_fft &lt;- function(df, Ta, N, name_sig, monolateral = TRUE) {\n  \n  df &lt;- df %&gt;% mutate(\n    f = n/Ta,\n    fft = fft({{ name_sig }}),\n    mod = ifelse(monolateral, (2-(f==0)), 1) * Mod(fft) / length(n),\n    phase = Arg(fft)/pi*180\n  )\n  \n  if(monolateral)\n    return(df %&gt;% slice_head(n = floor(N/2)))\n  \n  df\n}\n\n\n# Nuovo tempo di campionamento (a causa dell'eliminazione delle code)\nTa &lt;- max(p.flt_2Hz$t) + 1/fs\nN &lt;- length(p.flt_2Hz$n)\n\n# Spettro dei segnali senza la componenti a f=0\np.flt_2Hz.fft &lt;- compute_fft(p.flt_2Hz, Ta, N, eps) %&gt;% slice(-1)\np.flt_5Hz.fft &lt;- compute_fft(p.flt_5Hz, Ta, N, eps) %&gt;% slice(-1)\np.flt_7Hz.fft &lt;- compute_fft(p.flt_7Hz, Ta, N, eps) %&gt;% slice(-1)\n\nbind_rows(\n  p.flt_2Hz.fft %&gt;% mutate(caso = \"2 Hz\"),\n  p.flt_5Hz.fft %&gt;% mutate(caso = \"5 Hz\"),\n  p.flt_7Hz.fft %&gt;% mutate(caso = \"7 Hz\")\n) %&gt;% dplyr::filter(f &lt; 50) %&gt;% \n  ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(angle = pi/2, y=0, radius = mod), linewidth = 0.2, colour = \"#F8766D\") +\n  geom_point(colour = \"#F8766D\") +\n  facet_wrap(~ caso, ncol = 1, scales = \"free_x\") +\n  labs(\n    x = \"Frequenza (Hz)\",\n    y = \"Ampiezza Residui (mmHg)\",\n    title = \"Spettri dei segnali filtrati\"\n  )\n\n\n\n\n\n\n\n\n\ntmp &lt;- list(fc_2 = p.flt_2Hz, fc_5 = p.flt_5Hz, fc_7 = p.flt_7Hz)\n\nstats &lt;-  tibble(\n  fc = c(\"2 Hz\", \"5 Hz\", \"7 Hz\"),\n  mean = map_dbl(tmp, ~ mean(.x$eps)),\n  sd = map_dbl(tmp, ~ sd(.x$eps))\n)\n\nknitr::kable(stats, digits = 2, caption = \"Statistiche dei residui\")\n\n\nStatistiche dei residui\n\n\nfc\nmean\nsd\n\n\n\n\n2 Hz\n0.08\n6.02\n\n\n5 Hz\n-0.01\n1.76\n\n\n7 Hz\n-0.04\n0.71\n\n\n\n\n\nAnche osservando lo spettro dei residui è chiaro come avere una frequenza di taglio troppo bassa porti ad allontanarsi dall’andamento nominale. Infatti la dispersione dei residui tende ad aumentare (si guardi al valore di deviazione standard).\n\nFrequenza di taglio finale.\n\nDunque, per concludere, da un lato non è opportuno filtrare troppo tardi, poiché non verrebbe filtrato sufficientemente il rumore del segnale. Dall’altra, anticipare eccessivamente il taglio implica una distorsione dal segnale di riferimento, di cui un buon indicatore è la deviazione standard dei residui; questo fenomeno è dovuto a una soverchiante attenuazione di componenti in frequenza, magari proprie del segnale nominale stesso. Quindi, sulla base delle precedenti osservazioni, si sceglie una frequenza di taglio pari a \\(f_c = 7\\,\\mathrm{Hz}\\), ritenuta la più approssimativa del segnale ricostruito con Fourier."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Esercitazioni di esame",
    "section": "",
    "text": "Questo sito contiene la raccolta di esercitazioni da consegnare all’esame di Misure Industriali, del corso di Ingegneria Industriale, presso l’Università di Trento.\nLe esercitazioni fanno riferimento al sito relativo al corso di insegnamento.\npoi devo mettere le librerie in un htmle per vedere tutto formattata bene a codice\n\nQuesti riquadri servono a mettere in rilievo quando viene data risposta ai quesiti dell’esercitazione.\n\n\n1 Contenuti\n\nLibrerie:\n\ndig_signal_proc.R: funzioni relative al digital signal processing\ngraphics.R: funzioni relative alla formattazione della grafica\n\nEsercitazione 1 - Segnale di onda pressoria\nEsercitazione 2 - Modulazione di ampiezza\nEsercitazione 3 - Taratura dinamica tramite regressione non lineare\nEsercitazione 4 - Compensazione dinamica\nEsercitazione 5- Inversione delle armoniche pure"
  },
  {
    "objectID": "ex2.html",
    "href": "ex2.html",
    "title": "Esercitazione 2",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie."
  },
  {
    "objectID": "ex2.html#modulazione",
    "href": "ex2.html#modulazione",
    "title": "Esercitazione 2",
    "section": "2.1 Modulazione",
    "text": "2.1 Modulazione\n\n# Onda portante: carrier &lt;- cos(2 * pi * fp * t)\n# Aggiungiamo alla struttura associata alla misura il segnale modulato:\nym &lt;- ym %&gt;% mutate(\n    yn_m = (1 + m * ym$yn) * cos(2 * pi * fp * t),\n    fft_m = fft(yn_m),\n    intensity_m = Mod(fft_m) / length(t)*2,\n    phase_m = Arg(fft_m)/pi*180\n  )\n\nym %&gt;% pivot_longer(\n    cols = c(yn, yn_m)\n  ) %&gt;% mutate(\n    name = factor(name, levels = c(\"yn_m\", \"yn\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(\n    \"yn_m\" = \"Modulato\",\n    \"yn\" = \"Misurato\"\n  )) +\n  labs(x = \"Tempo (s)\", y = \"Segnale\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\n\nplot_ly() %&gt;%\n  add_bars(data = ym, x = ~f, y = ~intensity, name = \"Segnale\", marker = list(color = \"blue\")) %&gt;%\n  add_bars(x = r$f, y = r$intensity, name = \"Rumore\", marker = list(color = \"red\")) %&gt;%\n  add_bars(data = ym, x = ~f, y = ~intensity_m, name = \"Segnale Modulato\", marker = list(color = \"green\")) %&gt;%\n  layout(title = \"Spettro di Intensità\",\n       xaxis = list(title = \"Frequenza (Hz)\", range = c(0, 500), showgrid = TRUE),\n       yaxis = list(title = \"Intensità\", showgrid = TRUE),\n       legend = list(x = 0.25, y = 0.9))"
  },
  {
    "objectID": "ex2.html#esposizione-del-segnale-modulato-al-rumore",
    "href": "ex2.html#esposizione-del-segnale-modulato-al-rumore",
    "title": "Esercitazione 2",
    "section": "2.2 Esposizione del segnale modulato al rumore",
    "text": "2.2 Esposizione del segnale modulato al rumore\n\n# Effetto interferente sul segnale modulato:\nym &lt;- ym %&gt;% mutate(\n    yn_m_n = yn_m + r$y,\n    fft_m = fft(yn_m_n),\n    intensity_m = Mod(fft_m) / length(t)*2,\n    phase_m = Arg(fft_m)/pi*180\n  )\n\nplot_ly() %&gt;%\n  add_lines(data = ym, x = ~f, y = ~intensity_m, type = \"bar\", name = \"Segnale\", marker = list(color= \"blue\")) %&gt;%\n  layout(title = \"Spettro segnale modulato affetto da rumore\",\n       xaxis = list(title = \"Frequenza (Hz)\", range = c(0, 500), showgrid = TRUE),\n       yaxis = list(title = \"Intensità\", showgrid = TRUE))\n\n\n\n\n\n\nplot_ly() %&gt;%\n  add_lines(data = ym, x = ~t, y = ~yn_m, name = \"Segnale modulato\") %&gt;%\n  add_lines(data = ym, x = ~t, y = ~yn_m_n, name = \"Con effetto interferente\") %&gt;%\n  layout(title = \"Segnale modulato affetto da rumore\", \n         xaxis = list(title = \"Tempo (s)\"), \n         yaxis = list(title = \"Segnale\"))"
  },
  {
    "objectID": "ex2.html#eliminazione-del-rumore-interferente",
    "href": "ex2.html#eliminazione-del-rumore-interferente",
    "title": "Esercitazione 2",
    "section": "3.1 Eliminazione del rumore interferente",
    "text": "3.1 Eliminazione del rumore interferente\nOsservando lo spettro del segnale modulato esposto al rumore interferente, è evidente come le componenti di rumore siano separate da quelle del segnale modulato, che si trova ad alta frequenza. Pertanto, può essere implementato un filtro digitale passa-alto offline per selezionare solo quello modulato.\n\nFiltro passa-alto.\n\nInizialmente è stato scelto un filtro Butterworth, il cui ordine e frequenza di taglio sono stati selezionati a tentativi, affinché attenuassero il più possibile l’ultima componente di rumore a 135 Hz senza ridurre eccessivamente il segnale modulato.\n\nf_cutoff &lt;- 200\nflt.butter &lt;- butter(4, f_cutoff/(fc/2), type = \"high\")  # filtro Butterworth passa-alto\n\nggbodeplot_digital(flt.butter, fc, fmin = 1e1) + geom_vline(xintercept = f_cutoff, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- tibble(\n  t = ym$t,\n  yn = ym$yn,\n  yn_m = ym$yn_m,\n  yn_m_n = ym$yn_m_n,\n  yn_m_n.flt = signal::filtfilt(flt.butter, yn_m_n),   # estrae il segnale modulato\n  f = 0:(length(t)-1)/max(t),\n  fft = fft(yn_m_n.flt),\n  intensity = Mod(fft)/length(t)*2,\n  phase = Arg(fft)*180/pi\n) \n\nym.flt %&gt;% dplyr::filter(f &lt;= fc/2) %&gt;% plot_ly(x = ~f) %&gt;%\n  add_lines(y = ~intensity) %&gt;%\n  layout(xaxis = list(title=\"Frequenza (Hz)\"), yaxis=list(title=\"Intensità\"), title=\"Filtraggio del segnale modulato con filtro Butterworth\")\n\n\n\n\n\nTuttavia, nello spettro compare ancora una componente di rumore e il segnale in banda trasmessa risulta leggermente attenuato. Dunque, viene implementato un filtro di tipo Chebishev II, il quale a parità di ordine del Butterfly possiede una banda di transizione più ripida. Questo genere di filtro introdurrà un ripple in banda di stop, che però verrà attenuato mediante un filtraggio delle basse frequenze, che è richiesto per eliminare il rumore bianco. Nello specifico, a tentativi è stato scelto un taglio pari alla componente di più alta frequenza del rumore interferente.\n\nf_cutoff &lt;- max(pars_r$f)\nflt.cheby &lt;- cheby2(4, 20, f_cutoff/(fc/2), type = \"high\")  # N.B.: 20dB di riduzione del ripple in stop band\n\nggbodeplot_digital(flt.cheby, fc, fmin = 1e1) + geom_vline(xintercept = f_cutoff, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- ym.flt %&gt;% mutate(\n  yn_m_n.flt = signal::filtfilt(flt.cheby, yn_m_n),   # estrae il segnale modulato\n  f = 0:(length(t)-1)/max(t),\n  fft = fft(yn_m_n.flt),\n  intensity = Mod(fft)/length(t)*2,\n  phase = Arg(fft)*180/pi\n) \n\nym.flt %&gt;% dplyr::filter(f &lt;= fc/2) %&gt;% plot_ly(x = ~f) %&gt;%\n  add_lines(y = ~intensity) %&gt;%\n  layout(xaxis = list(title=\"Frequenza (Hz)\"), yaxis=list(title=\"Intensità\"), title=\"Filtraggio del segnale modulato con filtro Chebyshev II\")\n\n\n\n\n\nInfatti, ora lo spettro mostra il rumore essere quasi inesistente e il segnale trasmesso quasi privo di attenuazione.\n\nym.flt %&gt;% plot_ly(x = ~t) %&gt;%\n  add_lines(y = ~yn_m_n, name = \"Con rumore interferente\") %&gt;%\n  add_lines(y = ~yn_m, name = \"Modulato\") %&gt;%\n  add_lines(y = ~yn_m_n.flt, name = \"Filtrato\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"Segnale\"), title = \"Estrazione del segnale modulato\")\n\n\n\n\n\nA conferma del corretto procedimento di filtraggio è il fatto che il segnale ottenuto corrisponde a quello modulato prima dell’esposizione al rumore."
  },
  {
    "objectID": "ex2.html#demodulazione",
    "href": "ex2.html#demodulazione",
    "title": "Esercitazione 2",
    "section": "3.2 Demodulazione",
    "text": "3.2 Demodulazione\n\nDemodulazione.\n\nIl processo di demodulazione è quello che permette di separare il segnale misurato dalla portante. A tal fine, viene scelta la demodulazione sincrona [suggerimento ChatGPT], in cui il segnale modulato viene moltiplicato per un’armonica pura con stessa frequenza e fase della portante (per questo si chiama “sincrona”). Nello specifico, i passaggi da seguire sono i seguenti:\n\n:\n\n\\[\\begin{aligned}\ny_{mix} :&= y_{mod}(t) \\cdot \\cos(2\\pi f_p t) \\\\\n&= (1 + m y(t)) \\cos^2(2\\pi f_p t) \\\\\n&= (1+my(t))\\frac{1+\\cos(4\\pi f_p t)}{2} \\\\\n&= \\frac{1}2 (1+m y(t)) + \\frac{1}2 (1+my(t))\\cos(4 \\pi f_p t) .\n\\end{aligned}\\]\n\nFiltraggio passa-basso: il segnale ottenuto dal mixing è caratterizzato da una componente a bassa frequenza (pari al più a \\(f_{max}\\) del segnale misurato) ed una ad alta frequenza (pari a \\(2f_p\\)): \\[\nLP\\{y_{mix}\\}(f_{max} &lt; f_{cutoff} \\ll 2f_p) \\longrightarrow y_{flt} \\approx 1+my(t) .\n\\]\nRielaborazione matematica per ottenere il segnale misurato:\n\n\\[\n\\frac{1}m (y_{flt} - 1) = y(t) .\n\\]\nIn particolare, il filtro passa-basso permette anche di attenuare il ripple dal filtro Chebyshev e il rumore bianco.\n\nym.flt &lt;- ym.flt %&gt;% select(-fft, -intensity, -phase, -f) %&gt;% mutate(\n  y_mix = (2*yn_m_n.flt*cos(2*pi*fp*t) - 1)/m   # demodulazione + rielaborazione matematica\n)\n\n# Filtro passa-basso\n# Taglio al doppio della freq. max del segnale misurato\n# per far passare l'intero suo spettro\nf_cut2 &lt;- 2*max(pars_m$f)\nflt.butter.lp &lt;- butter(2, f_cut2/(fc/2))\n\nggbodeplot_digital(flt.butter.lp, fc, fmin = 1) + geom_vline(xintercept = f_cut2, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- ym.flt %&gt;% mutate(\n  y_flt2 = filtfilt(flt.butter.lp, y_mix)\n)\n\nym.flt %&gt;% plot_ly(x = ~t) %&gt;%\n  add_lines(y = ~yn_m_n.flt, name = \"Filtrato\") %&gt;%\n  add_lines(y = ~y_flt2, name = \"Demodulato\") %&gt;%\n  layout(xaxis = list(title=\"Tempo (s)\"), yaxis=list(title=\"Segnale\"), title = \"Demodulazione\")\n\n\n\n\n\n\nComparazione con la misura originale.\n\n\nym.flt %&gt;% pivot_longer(cols = c(\"yn\", \"y_flt2\")) %&gt;%\n  mutate(\n    name = factor(name, levels = c(\"yn\", \"y_flt2\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(yn = \"Originale\", y_flt2 = \"Demodulato\")) +\n  labs(x = \"Tempo (s)\", y = \"Segnale\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\nSi osservi come il processo di demodulazione ha permesso anche di filtrare il rumore."
  },
  {
    "objectID": "ex4.html",
    "href": "ex4.html",
    "title": "Esercitazione 4",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie."
  },
  {
    "objectID": "ex4.html#spettro-dei-segnali-misurati",
    "href": "ex4.html#spettro-dei-segnali-misurati",
    "title": "Esercitazione 4",
    "section": "2.1 Spettro dei segnali misurati",
    "text": "2.1 Spettro dei segnali misurati\n\nTa &lt;- max(u$t)\nun.fft &lt;- compute_fft(tmp, Ta, un)\nideal.fft &lt;- compute_fft(tmp, Ta, ideal)\nout.fft &lt;- compute_fft(tmp, Ta, out)\n\nbind_rows(\n  un.fft %&gt;% mutate(caso = \"Input\"),\n  ideal.fft %&gt;% mutate(caso = \"Output ideale\"),\n  out.fft %&gt;% mutate(caso = \"Output\")\n) %&gt;% dplyr::filter(f &lt; 1) %&gt;% \n  ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(angle = pi/2, y=0, radius = mod), linewidth = 0.2, colour = \"#F8766D\") +\n  geom_point(colour = \"#F8766D\") +\n  facet_wrap(~ caso, ncol = 1, scales = \"free_x\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\")\n\n\n\n\n\n\n\n\nNB: non si vede, ma il rumore bianco è presente. Provare ad ingrandire la sd del rumore addizionato a un."
  },
  {
    "objectID": "ex4.html#padding-simmetrico-a-zero",
    "href": "ex4.html#padding-simmetrico-a-zero",
    "title": "Esercitazione 4",
    "section": "3.1 Padding simmetrico a zero",
    "text": "3.1 Padding simmetrico a zero\n\n# Ampiezza padding\nM &lt;- 2*N\n\npad_left  &lt;- floor((M - N)/2)\npad_right &lt;- ceiling((M - N)/2)\nt_start &lt;- y$t[1] - pad_left * Ts\n\ny_ext &lt;- tibble(\n  t = seq(from = t_start, by = Ts, length.out = M),\n  y_pad = c(\n    rep(0, pad_left),\n    y$y_flt,\n    rep(0, pad_right)\n  )\n)\n\n# Verifica che il segnale sia centrato: deve restituire TRUE\n#all.equal(y_ext$y_pad[(pad_left+1):(pad_left+N)],y$y_flt)\n\n\n\n\n\n\n\n\n\n\n\n# Nuovo asse delle frequenze\nfreq &lt;- tibble(\n  k = 0:(M-1),\n  f = ifelse(k &lt;= M/2, k, k-M) * fs/M,   # FFT simmetrica nell'asse delle freq.\n  w = 2*pi*f\n)\n\nHiw &lt;- freqresp(H, freq$w)\n\ny_ext &lt;- y_ext %&gt;% mutate(\n  Y_pad = fft(y_pad),\n  U_pad = Y_pad/Hiw,\n  u_pad = Re(fft(U_pad, inverse = TRUE)) / M\n)\n\n# Scarto delle code di padding\nu_comp &lt;- u_comp %&gt;% mutate(\n  u_pad = y_ext$u_pad[(pad_left+1):(pad_left+N)]\n)\n\n\n\n\n\n\n\nQuesta volta il segnale compensato coincide molto bene con quello ideale. Ciononostante, si osserva ancora un alto contenuto in frequenza nelle code. Quest’ultimo viene eliminato mediante un’operazione di filtraggio.\n\n# Verifico lo spettro del segnale\ncompute_fft(u_comp, Ta, u_pad) %&gt;% dplyr::filter(f &lt; 2) %&gt;%\n  ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(angle = pi/2, y=0, radius = mod), linewidth = 0.2, colour = \"#56B4E9\") +\n  geom_point(colour = \"#56B4E9\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\", title = \"Spettro dell'ingresso compensato\")\n\n\n\n\n\n\n\n\n\nfc &lt;- 2\nflt &lt;- butter(2, 2*fc/fs)\n\nu_comp &lt;- u_comp %&gt;% mutate(\n  u_flt = signal::filtfilt(flt, u_pad)\n)\n\n\n\n\n\n\n\nAdesso si osserva che l’ingresso viene riprodotto fedelmente. Di seguito un confronto tra segnale di uscita e ingresso compensato:"
  },
  {
    "objectID": "ex5.html#filtraggio-del-segnale-di-output",
    "href": "ex5.html#filtraggio-del-segnale-di-output",
    "title": "Esercitazione 5",
    "section": "5.1 Filtraggio del segnale di output",
    "text": "5.1 Filtraggio del segnale di output\nDallo spettro dell’uscita le componenti di rimuro risulta veramente irrisorie, pertanto il segnale non verrà filtrato. Comunque, la FdT mostra un comportamento passa-basso, pertanto la sua inversa sarà un passa-alto, che amplificherà gran parte delle componenti, avendo il segnale d’uscita diverse componenti armoniche oltre la frequenza d’i taglio’attenuazione \\(2.25\\,\\mathrm{Hz}\\). Dunque, un filtraggio a valle della compensazione sarà necessario lo stesso.\nNB: è stato provato a filtrare l’uscita e si è visto che poi effettuando la compensazione il segnale ricostruito avesse ampiezza inferiore a quella ideale\n\ny &lt;- s %&gt;% dplyr::select(t, y) \n\nspectrum_fft(y, name_sig = \"y\") %&gt;% #dplyr::filter(f &lt; 100) %&gt;% \n  ggplot(aes(f, mod)) +\n  geom_spoke(aes(y = 0, radius = mod, angle = pi/2), color = \"#56B4E9\") +\n  geom_point(color = \"#56B4E9\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\")"
  },
  {
    "objectID": "ex5.html#compensazione-delluscita",
    "href": "ex5.html#compensazione-delluscita",
    "title": "Esercitazione 5",
    "section": "5.2 Compensazione dell’uscita",
    "text": "5.2 Compensazione dell’uscita\n\n#y &lt;- s %&gt;% dplyr::select(t, y)\nu &lt;- s %&gt;% select(t, u, u_n) %&gt;%\n  mutate(\n    u_comp = dyn_compensation(y, H, name_sig = \"y\")$u\n  )\n\n\nu %&gt;%\n  plot_ly(x = ~t) %&gt;%\n  add_lines(y = y$y, name = \"Output\") %&gt;%\n  add_lines(y = ~u_comp, name = \"Compensato\") %&gt;%\n  add_lines(y = ~u, name = \"Ideale\")"
  },
  {
    "objectID": "ex5.html#filtraggio-dellingresso-compensato",
    "href": "ex5.html#filtraggio-dellingresso-compensato",
    "title": "Esercitazione 5",
    "section": "5.3 Filtraggio dell’ingresso compensato",
    "text": "5.3 Filtraggio dell’ingresso compensato\n\nspectrum_fft(u, name_sig = \"u_comp\") %&gt;% \n  ggplot(aes(f, mod)) +\n  geom_spoke(aes(y = 0, radius = mod, angle = pi/2), color = \"#F8766D\") +\n  geom_point(color = \"#F8766D\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\")\n\n\n\n\n\n\n\n\nIl segnale compensato mostra solo la presenza di rumore bianco, e non di altri tipi. Perciò, non avrebbe senso filtrare le basse frequenze, attenuando così solo il rumore alle alte.\nDunque viene implementato un algoritmo che seleziona solo le armoniche la cui intensità relativa al massimo di intensità è oiù alta di una certa so\nenergia spettrale relativa è più alta di una soglia determinata dall’utente. Il contributo energetico relativo, rappresentativo del segnale nel tempo in virtù del Teorema di Parseval, viene calcolato come segue:\n\\[\ne_k = \\frac{|Y_k|^2}{\\sum_k |Y_k|^2}\n\\]\n\nN &lt;- nrow(u)\nk &lt;- 0:(N-1)\n\nthreashold &lt;- 0.05  # 5% en. totale\n\nu_spectrum &lt;- tibble(\n    f = ifelse(k &lt;= N/2, k, k-N) * fs/N,\n    u_fft = fft(u$u_comp),\n    mod = Mod(u_fft)/N\n)\n\nu_spectrum  %&gt;% dplyr::filter(mod &gt; 0.025) %&gt;%\n  mutate(mod = (2 - (f==0)) * mod) %&gt;% dplyr::filter(f &gt;= 0) %&gt;%\n  ggplot(aes(f, mod)) +\n  geom_spoke(aes(y = 0, radius = mod, angle = pi/2), color = \"#F8766D\") +\n  geom_point(color = \"#F8766D\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\")\n\n\n\n\n\n\n\n\nprendi segnale compensato -&gt; calcola lo spettro (neg, pos) -&gt; calcola energia -&gt; filtra energia\n\n# Calcolo il nuovo segnale con FFT^-1\nu &lt;- u %&gt;% mutate(\n    u_new = Re(fft(u_spectrum$u_fft, inverse = T))/N\n  )\n\n\nu %&gt;%\n  plot_ly(x = ~t) %&gt;%\n  add_lines(y = y$y, name = \"Output\") %&gt;%\n  add_lines(y = ~u_comp, name = \"Compensato\") %&gt;%\n  add_lines(y = ~u, name = \"Ideale\") %&gt;%\n  add_lines(y = ~u, name = \"Selezionato\")"
  },
  {
    "objectID": "ex5.html#mediante-picchi",
    "href": "ex5.html#mediante-picchi",
    "title": "Esercitazione 5",
    "section": "5.1 Mediante picchi",
    "text": "5.1 Mediante picchi\nDunque viene implementato un algoritmo che seleziona solo le armoniche la cui intensità relativa al massimo di intensità è maggiore di una certa soglia scelta dall’utente. In pratica, si selezionano solo le armoniche pure del segnale, che in questo caso si conoscono a priori.\nVisivamente viene determinata la soglia sul modulo della trasformata, ricordando che nello spettro monolatero è rappresentato il doppio dell’intensità.\n\n\n\n\n\n\n\n\n\n\nN &lt;- nrow(u)\nk &lt;- 0:(N-1)\n\nthreashold &lt;- 0.04\n\nu_spectrum &lt;- tibble(\n    f = ifelse(k &lt;= N/2, k, k-N) * fs/N,\n    U = fft(u$u_comp),\n    mask = Mod(U)/N &gt; threashold,\n    U_filtered = U*mask\n)\n\nu_spectrum %&gt;% mutate(mod = Mod(U_filtered)/N) %&gt;% ggplot(aes(f, mod)) + geom_line()\n\n\n\n\n\n\n\n# Calcolo il nuovo segnale con FFT^-1\nu &lt;- u %&gt;% mutate(\n    u_new = Re(fft(u_spectrum$U_filtered, inverse = T))/N\n  )\n\n\nu %&gt;%\n  plot_ly(x = ~t) %&gt;%\n  add_lines(y = ~u_new, name = \"Selezionato\") %&gt;%\n  add_lines(y = ~u, name = \"Ideale\") \n\n\n\n\n\nCome era prevedibile la componente di rumore bianco è pressoché irrisoria rispetto alle armoniche pure. Comunque è un buon algoritmo per eliminare il rumore bianco.\n\n# Calcolo i residui tra ideale e ricostruito\neps &lt;- tibble(\n  t = u$t,\n  e = u$u - u$u_new\n)\n\neps %&gt;% ggplot(aes(x = t, y = e)) + geom_point()"
  }
]