[
  {
    "objectID": "ex3.html",
    "href": "ex3.html",
    "title": "Esercitazione 3",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie.\n\n1 Funzione di trasferimento e risposta al gradino\n\nFunzione di trasferimento e risposta al gradino.\n\nIl principio alla base per ricavare la funzione di trasferimento del sistema è il bilancio delle potenze termiche scambiate:\n\\[\nm c \\frac{d}{dt} T(t) = \\alpha A(T_{amb}(t)-T(t)) \\overset{\\mathcal{F}}{\\longrightarrow} mc \\, j\\omega T(j\\omega) =\\alpha A (T_{amb}(j\\omega) - T(j\\omega)).\n\\]\nPerciò, bilanciando la potenza scambiata tra sonda (uscita del sistema) e guaina, si ottiene:\n\\[\\begin{aligned}\nm_s c_s \\, j\\omega T_s(j\\omega) &= \\alpha_{gs} A_{gs} (T_{g}(j\\omega) - T_s(j\\omega)) \\\\\n\\Leftrightarrow \\frac{T_s(j\\omega)}{T_g(j\\omega)} &= \\frac{1}{\\tau_1 \\, j\\omega + 1} ,\n\\end{aligned}\\]\ndove \\(\\tau_2 = \\frac{M_s c_s}{\\alpha_{gs} A_{gs}}\\).\nMediante gli stessi procedimenti, si può esprimere anche la potenza scambiata tra il misurando (input del sistema) e la guaina:\n\\[\\begin{aligned}\nm_g c_g \\, j\\omega T_g(j\\omega) &= \\alpha_{mg} A_{gs} (T_{m}(j\\omega) - T_g(j\\omega)) \\\\\n\\Leftrightarrow \\frac{T_g(j\\omega)}{T_m(j\\omega)} &= \\frac{1}{\\tau_2 \\, j\\omega + 1} ,\n\\end{aligned}\\]\ndove dove \\(\\tau_1 = \\frac{M_g c_g}{\\alpha_{mg} A_{mg}}\\).\nPertanto, esprimendo \\(T_g\\) in funzione di \\(T_m\\), si ricava la funzione di risposta in frequenza tra misura (sonda) e misurando:\n\\[\nH(j\\omega) = \\frac{1}{\\tau_1 \\tau_2 (j \\omega)^2 + (\\tau_1 + \\tau_2)j\\omega + 1}.\n\\]\nRiguardo alla risposta allo scalino da \\(T_i\\) a \\(T_f\\) nelle condizioni di \\(\\tau_1 &gt; \\tau_2\\), si modella il gradino come segue, traslato di \\(T_i\\):\n\\[\\begin{aligned}\nT_m(t) = T_i + (T_f - T_i)\\,\\text{sca}(t) &\\overset{T_i = \\text{cost}}{\\Leftrightarrow} \\vartheta_m(t) := T_m(t) - T_i = (T_f - T_i)\\,\\text{sca}(t) \\\\\n&\\overset{\\mathcal{L}}{\\longrightarrow} \\Theta_m(s) = (T_f - T_i)\\frac{1}s .\n\\end{aligned}\\]\nSi definisce anche l’uscita traslata di \\(T_i\\):\n\\[\n\\vartheta_s(t) := T_s(t) - T_i \\overset{\\mathcal{L}}{\\longrightarrow} \\Theta_s(s).\n\\]\nIn virtù della natura LTI del sistema, la risposta allo scalino nel dominio della frequenza è pari a\n\\[\n\\Theta_s(s) = H(s) \\cdot (T_f - T_i)\\frac{1}s.\n\\]\nMediante la scomposizione per fratti semplici e poi anti-trasformando, si ottiene la risposta nel dominio nel tempo:\n\\[\nT_s(t) = T_f + (T_i+T_f) \\cdot \\left( \\frac{\\tau_1}{\\tau_1 - \\tau_2} e^{-\\frac{t}{\\tau_1}} - \\frac{\\tau_2}{\\tau_1 - \\tau_2} e^{-\\frac{t}{\\tau_2}} \\right) .\n\\]\n\n\n2 Segnale campionato\nIl set di dati è disponibile a questo link.\n\ndf &lt;- read.table(\"datiPT100_2005Taratura.txt\", header=FALSE, sep=\"\\t\", dec=\",\", stringsAsFactors=FALSE)\ncolnames(df) &lt;- c(\"t\", \"temp\", \"temp_f\")\n\ndf &lt;- df %&gt;% dplyr::filter(t &gt;= 150) %&gt;% select(-temp_f) %&gt;%\n  mutate(t = t - 150)\n\ndf %&gt;% plot_ly(x = ~t, y = ~temp) %&gt;%\n  add_lines() %&gt;% \n  layout(xaxis = list(title=\"Tempo (s)\"), yaxis = list(title=\"Temperatura (°C)\"), title=\"Segnale di temperatura campionato\")\n\n\n\n\n\n\n# Verificato campionamento regolare con media e sd\nfs &lt;- 1/(df$t[2]-df$t[1]) # freq. di campionamento\nTa &lt;- max(df$t) # tempo di acquisizione: primo istante a 0 sec\n\nParametri di campionamento (regolare):\n\n\\(f_s =5.99\\,\\mathrm{Hz}\\)\n\\(T_a =244.67\\,\\mathrm{s}\\)\n\n\n\n3 Taratura costanti \\(\\tau_1\\) e \\(\\tau_2\\)\n\nRegressione sulle sole costanti di tempo.\n\n\nt0 &lt;- 28                        # soglia temporale tra plateau e transizione\nTi &lt;- mean(df$temp[df$t &lt; t0])\nTf &lt;- 82                        # attribuito visivamente\n\n# Modello fisico: risposta allo scalino\ntemperature &lt;- function(t, t0, Ti, Tf, tau1, tau2) {\n  ifelse(\n    t &lt; t0,\n    Ti,\n    Tf + (Ti-Tf)*(\n      tau1/(tau1-tau2)*exp( - (t-t0)/tau1 ) -\n      tau2/(tau1-tau2)*exp( - (t-t0)/tau2 )\n    )\n  )\n}\n\ndf.nls &lt;- nls(temp ~ temperature(t, t0, Ti, Tf, tau1, tau2),\n              data = df, start = list(tau1 = 30, tau2=25)\n            )\nsummary(df.nls)\n\n\nFormula: temp ~ temperature(t, t0, Ti, Tf, tau1, tau2)\n\nParameters:\n     Estimate Std. Error t value Pr(&gt;|t|)    \ntau1 31.41414    0.06063  518.10   &lt;2e-16 ***\ntau2  0.86715    0.04374   19.83   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4801 on 1467 degrees of freedom\n\nNumber of iterations to convergence: 9 \nAchieved convergence tolerance: 4.686e-06\n\n\n\ndf &lt;- df %&gt;% add_predictions(df.nls) %&gt;% add_residuals(df.nls)\n\np1 &lt;- df %&gt;% ggplot(aes(x = t)) +\n  geom_line(aes(y = temp)) +\n  geom_line(aes( y = pred), color = \"red\") +\n  labs(x=\"Tempo (s)\", y=\"Temperatura (°C)\")\n\np2 &lt;- df %&gt;% ggplot(aes(x = t, y = resid)) +\n  geom_point() +\n  geom_vline(xintercept = as.numeric(coef(df.nls)[1]), color = \"orange\", linetype = 2) +\n  labs(x=\"Tempo (s)\", y=\"Residui (°C)\")\n\np1+p2\n\n\n\n\n\n\n\n\nOsservando i residui, è evidente un pattern di questi durante la fase di transizione che suggerisce un underfitting dei dati. Questo potrebbe essere sintomo che il modello fisico ipotizzato non sia adeguato. Peraltro, i parametri regrediti suggeriscono un comportamento predominante dalla costante di tempo \\(\\tau_1\\).\nTuttavia, graficamente è chiaro come la regressione nls segua bene le misure sperimentali e comunque si parla di una dispersione dei residui di circa \\(\\pm1 \\,\\mathrm{°C}\\).\n\n\n4 Taratura su tutti i parametri\n\nRegressione su tutti i parametri.\n\n\nparams &lt;- list(t0 = t0,\n               Ti = Ti,\n               Tf = Tf,\n               tau1 = as.numeric(coef(df.nls)[1]),\n               tau2 = as.numeric(coef(df.nls)[2])\n            )\n\ndf.nls2 &lt;- nls(temp ~ temperature(t, t0, Ti, Tf, tau1, tau2),\n               data = df, start = params)\nsummary(df.nls2)\n\n\nFormula: temp ~ temperature(t, t0, Ti, Tf, tau1, tau2)\n\nParameters:\n     Estimate Std. Error t value Pr(&gt;|t|)    \nt0   24.89962    0.13417  185.58   &lt;2e-16 ***\nTi   28.12231    0.03563  789.33   &lt;2e-16 ***\nTf   81.80832    0.01983 4124.48   &lt;2e-16 ***\ntau1 30.08639    0.10480  287.10   &lt;2e-16 ***\ntau2  4.71385    0.16979   27.76   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4449 on 1464 degrees of freedom\n\nNumber of iterations to convergence: 12 \nAchieved convergence tolerance: 5.334e-06\n\n\n\ndf &lt;- df %&gt;% add_predictions(df.nls2) %&gt;% add_residuals(df.nls2)\n\np1 &lt;- df %&gt;% ggplot(aes(x = t)) +\n  geom_line(aes(y = temp)) +\n  geom_line(aes( y = pred), color = \"red\") +\n  labs(x=\"Tempo (s)\", y=\"Temperatura (°C)\")\n\np2 &lt;- df %&gt;% ggplot(aes(x = t, y = resid)) +\n  geom_point() +\n  geom_vline(xintercept = as.numeric(coef(df.nls2)[1]), color = \"orange\", linetype = 2) +\n  labs(x=\"Tempo (s)\", y=\"Residui (°C)\")\n\np1+p2\n\n\n\n\n\n\n\n\nAnche in questo caso i residui continuano a mostrare un determinato andamento nella fase di transizione, ma visivamente la regressione si ben adatta alle misure sperimentali.\n\n\n5 Intervallo di confidenza dei parametri\n\nIntervallo di confidenza dei parametri mediante bootstrap.\n\nL’intervallo di confidenza (IC) viene calcolato al \\(95\\%\\): ossia è quell’intervallo al quale i parametri regrediti appartengono con tale probabilità.\n\n# Funzione che calcola i parametri di nls ad ogni ripetizione \n# per questa ragione sono delle statistiche\nstats &lt;- function(temp, data) {\n  fit &lt;- nls(temp ~ temperature(t, t0, Ti, Tf, tau1, tau2), \n             data = data, start = params)\n  return(fit$m$getPars())\n}\n\n# Bootstrap NON parametrico (con reinserimento di default)\ndf.b &lt;- boot(df, \\(x,i) stats(x[i, \"temp\"], x[i,]), R=10^4)\n\ndf.b\n\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = df, statistic = function(x, i) stats(x[i, \"temp\"], \n    x[i, ]), R = 10^4)\n\n\nBootstrap Statistics :\n     original        bias    std. error\nt1* 24.899622 -1.753226e-02  0.30676865\nt2* 28.122310 -6.974533e-05  0.03648827\nt3* 81.808320 -8.824149e-04  0.02414173\nt4* 30.086388 -1.497420e-02  0.16527394\nt5*  4.713854  2.771949e-02  0.39443053\n\n\nÈ verificato che le stime regredite coincidono con la regressione precedente, per cui si accetta il calcolo senza ulteriori dimostrazioni (e.g. un grafico QQ di ciascun parametro per capire se il numero di ripetizioni \\(R\\) è adeguato).\n\n# Intervallo di confidenza al 95% (metodo percentile)\nci &lt;- list(\n  t0 = boot.ci(df.b, type = \"perc\", index = 1)$percent[4:5],\n  Ti = boot.ci(df.b, type = \"perc\", index = 2)$percent[4:5],\n  Tf = boot.ci(df.b, type = \"perc\", index = 3)$percent[4:5],\n  tau1 = boot.ci(df.b, type = \"perc\", index = 4)$percent[4:5],\n  tau2 = boot.ci(df.b, type = \"perc\", index = 5)$percent[4:5]\n)\n\nGraficando l’IC, si mostra quanto sia incerta la stima della curva regredita.\nInteressanti sono gli IC relativi a \\(t_0, T_i\\) e \\(T_f\\).\n\n\n\n\n\n\n\n\n\nMentre su tutta la curva, combinando i diversi IC, si ottiene:\n\n# Funzione che calcola l'estremo alto o basso dell'IC\n# per ogni possibile combinazione degli estremi di IC\n# di ciascun parametro\nf_conf &lt;- function(t, temperature, ci, upper=TRUE) {\n  df &lt;- expand.grid(ci)       # ogni possibile combinazione di IC\n  df$temp &lt;- with(df, temperature(t, t0, Ti, Tf, tau1, tau2))\n  ifelse(upper, max(df$temp), min(df$temp))\n}\n\ndf %&gt;% mutate(\n  lower = map_dbl(t, ~f_conf(., temperature, ci, upper=FALSE)),\n  upper = map_dbl(t, ~f_conf(., temperature, ci))\n) %&gt;% ggplot(aes(x=t)) +\n  geom_ribbon(aes(ymin = lower, ymax = upper), fill=\"blue\", alpha=.5) +\n  geom_line(aes(y=temp)) +\n  geom_line(aes(y=pred), color=\"red\") +\n  labs(x=\"Tempo (s)\", y=\"Temperatura (°C)\")\n\n\n\n\n\n\n\n\nSi osserva come l’incertezza nella fase di transizione risulti più ampia, verosimilmente riconducibile alla stima di \\(\\tau_1\\) e \\(\\tau_2\\). Tale comportamento può indicare una parziale inadeguatezza del modello fisico adottato oppure una difficoltà di nls nel raggiungere una soluzione ottimale."
  },
  {
    "objectID": "ex1.html",
    "href": "ex1.html",
    "title": "Esercitazione 1",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie.\nParametri di campionamento che verranno considerati nell’analisi:\n# Campionamento regolare\nfs &lt;- 1000      # freq. di campionamento\nTs &lt;- 1/fs      # periodo di campionamento"
  },
  {
    "objectID": "ex1.html#ricostruzione-mediante-serie-di-fourier",
    "href": "ex1.html#ricostruzione-mediante-serie-di-fourier",
    "title": "Esercitazione 1",
    "section": "1.1 Ricostruzione mediante serie di Fourier",
    "text": "1.1 Ricostruzione mediante serie di Fourier\nIl segnale viene ricostruito mediante le serie di Fourier, in cui l’\\(n\\)-esimo elemento vale:\n\\[\np[n] = a_0 + \\sum_{k = 1}^{K} a_k \\cos[2\\pi k f_0 \\, n] + \\sum_{k = 1}^{K} a_k \\sin[2\\pi k f_0  \\, n] ,\n\\]\ndove \\(f_0\\) è la frequenza fondamentale, \\(K\\) è il numero totale di componenti armoniche e \\(a_k, b_k\\) sono le \\(k\\)-esime componenti, risultato della scomposizione su basi orto-normali. Si osservi che la componente in DC non viene divisa per 2, perché è calcolata come la media del segnale, anziché il doppio della media (come da teoria della trasformata).\nLa \\(k\\)-esima componente avrà frequenza pari a \\(f_k = k f_0 = \\frac{k}{T_a}\\), dove \\(T_a = 10\\,\\mathrm{s}\\) è il tempo di acquisizione. Perciò, in virtù del Teorema di Nyquist-Shannon, deve valere la seguente disuguaglianza, per la quale si calcola la massima componente:\n\\[\nf_{max} = \\frac{k_{max}}{T_a} \\leq \\frac{f_s}2 \\Leftrightarrow k_{max} = \\frac{f_s T_a}{2} = 5000,\n\\] con \\(f_s = 1000\\,\\mathrm{Hz}\\) la frequenza di campionamento.\n\nRicostruzione segnale anche con i coseni.\n\n\na0 &lt;- mean(sig_art$p_art)\n\n# La componente DC è ortogonale alle basi seno e cose\n# Per evitare errori numerici, quest'ultima viene sottratta al segnale\np_art_osc &lt;- sig_art$p_art - a0\n\nK &lt;- 500 # massimo possibile: 5e3\nf_fund &lt;- 1/Ta\n\ncomps_cos &lt;- map_dbl(1:K, \\(k) {\n  c &lt;- cos_k(sig_art$t, f_fund, k)\n  p_art_osc %ps% c/norm_ps(c)\n}) %&gt;% zapsmall()\n\ncomps_sin &lt;- map_dbl(1:K, \\(k) {\n  s &lt;- sin_k(sig_art$t, f_fund, k)\n  p_art_osc %ps% s/norm_ps(s)\n}) %&gt;% zapsmall()\n\ncomps_sin[1:50]\n\n [1]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n [8]  0.000000  0.000000  9.340245  0.000000  0.000000  0.000000  0.000000\n[15]  0.000000  0.000000  0.000000  0.000000  0.000000  3.153407  0.000000\n[22]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n[29]  0.000000  3.164646  0.000000  0.000000  0.000000  0.000000  0.000000\n[36]  0.000000  0.000000  0.000000  0.000000  1.965583  0.000000  0.000000\n[43]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n[50] -0.061118\n\n\n\nRoutine mediante reduce.\n\n\n# Implementazione mediante reduce\nsig_art &lt;- sig_art %&gt;% mutate(\n  p_art_k = a0 + reduce(1:K, \\(acc, k) {\n    c &lt;- cos_k(t, f_fund, k)\n    s &lt;- sin_k(t, f_fund, k)\n    acc + comps_cos[k] * c/norm_ps(c) + comps_sin[k] * s/norm_ps(s)\n  }, .init = rep(0, n()))\n)\n\nplot_ly() %&gt;%\n  add_lines(x = sig_art$t, y = sig_art$p_art, name = \"Originale\") %&gt;%\n  add_lines(x = sig_art$t, y = sig_art$p_art_k, name = \"Ricostruito\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"Pressione (mmHg)\"), title = \"Ricostruzione del segnale\")"
  },
  {
    "objectID": "ex1.html#analisi-statica",
    "href": "ex1.html#analisi-statica",
    "title": "Esercitazione 1",
    "section": "3.1 Analisi statica",
    "text": "3.1 Analisi statica\n\nAnalisi statica dei residui.\n\n\n# Traslo il tempo a 0: fa comodo partire da lì\np.flt_5Hz &lt;- p.flt_5Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;%  \n  mutate(eps = p_k - p_flt)\n\np.flt_2Hz &lt;- p.flt_2Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;% \n  mutate(eps = p_k - p_flt)\n\np.flt_7Hz &lt;- p.flt_7Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;% \n  mutate(eps = p_k - p_flt)\n\nbind_rows(\n  p.flt_2Hz %&gt;% mutate(case = \"2 Hz\"),\n  p.flt_5Hz %&gt;% mutate(case = \"5 Hz\"),\n  p.flt_7Hz %&gt;% mutate(case = \"7 Hz\")\n) %&gt;% pivot_longer(\n  cols = c(p_k, p_flt)\n) %&gt;% mutate(\n    name = factor(name, levels = c(\"p_k\", \"p_flt\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(\n    \"p_k\" = \"Ricostruito\",\n    \"p_flt\" = \"Filtrato\"\n  )) +\n  facet_wrap(~ case, ncol = 1, scales = \"free_x\") +\n  labs(x = \"Tempo (s)\", y = \"Pressione (mmHg)\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\n\nbind_rows(\n  p.flt_2Hz %&gt;% mutate(caso = \"2 Hz\"),\n  p.flt_5Hz %&gt;% mutate(caso = \"5 Hz\"),\n  p.flt_7Hz %&gt;% mutate(caso = \"7 Hz\")\n) %&gt;% ggplot(aes(x = t, y = eps, colour = caso)) +\n  geom_point(size = 0.6, alpha = 0.6) +\n  labs(x = \"Tempo (s)\", y = \"Residui (mmHg)\", colour = latex2exp::TeX(\"$f_c\"))\n\n\n\n\n\n\n\n\nDai grafici soprastanti è evidente come anticipare il taglio distorga il segnale da quello di riferimento."
  },
  {
    "objectID": "ex1.html#analisi-in-frequenza",
    "href": "ex1.html#analisi-in-frequenza",
    "title": "Esercitazione 1",
    "section": "3.2 Analisi in frequenza",
    "text": "3.2 Analisi in frequenza\n\nAnalisi in frequenza dei residui.\n\n\n# Funzione per automatizzare il calcolo dello spettro\ncompute_fft &lt;- function(df, Ta, N, name_sig, monolateral = TRUE) {\n  \n  df &lt;- df %&gt;% mutate(\n    f = n/Ta,\n    fft = fft({{ name_sig }}),\n    mod = ifelse(monolateral, (2-(f==0)), 1) * Mod(fft) / length(n),\n    phase = Arg(fft)/pi*180\n  )\n  \n  if(monolateral)\n    return(df %&gt;% slice_head(n = floor(N/2)))\n  \n  df\n}\n\n\n# Nuovo tempo di campionamento (a causa dell'eliminazione delle code)\nTa &lt;- max(p.flt_2Hz$t) + 1/fs\nN &lt;- length(p.flt_2Hz$n)\n\n# Spettro dei segnali senza la componenti a f=0\np.flt_2Hz.fft &lt;- compute_fft(p.flt_2Hz, Ta, N, eps) %&gt;% slice(-1)\np.flt_5Hz.fft &lt;- compute_fft(p.flt_5Hz, Ta, N, eps) %&gt;% slice(-1)\np.flt_7Hz.fft &lt;- compute_fft(p.flt_7Hz, Ta, N, eps) %&gt;% slice(-1)\n\nbind_rows(\n  p.flt_2Hz.fft %&gt;% mutate(caso = \"2 Hz\"),\n  p.flt_5Hz.fft %&gt;% mutate(caso = \"5 Hz\"),\n  p.flt_7Hz.fft %&gt;% mutate(caso = \"7 Hz\")\n) %&gt;% dplyr::filter(f &lt; 50) %&gt;% \n  ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(angle = pi/2, y=0, radius = mod), linewidth = 0.2, colour = \"#F8766D\") +\n  geom_point(colour = \"#F8766D\") +\n  facet_wrap(~ caso, ncol = 1, scales = \"free_x\") +\n  labs(\n    x = \"Frequenza (Hz)\",\n    y = \"Ampiezza Residui (mmHg)\",\n    title = \"Spettri dei segnali filtrati\"\n  )\n\n\n\n\n\n\n\n\n\ntmp &lt;- list(fc_2 = p.flt_2Hz, fc_5 = p.flt_5Hz, fc_7 = p.flt_7Hz)\n\nstats &lt;-  tibble(\n  fc = c(\"2 Hz\", \"5 Hz\", \"7 Hz\"),\n  mean = map_dbl(tmp, ~ mean(.x$eps)),\n  sd = map_dbl(tmp, ~ sd(.x$eps))\n)\n\nknitr::kable(stats, digits = 2, caption = \"Statistiche dei residui\")\n\n\nStatistiche dei residui\n\n\nfc\nmean\nsd\n\n\n\n\n2 Hz\n0.11\n6.02\n\n\n5 Hz\n0.01\n1.74\n\n\n7 Hz\n-0.01\n0.71\n\n\n\n\n\nAnche osservando lo spettro dei residui è chiaro come avere una frequenza di taglio troppo bassa porti ad allontanarsi dall’andamento nominale. Infatti la dispersione dei residui tende ad aumentare (si guardi al valore di deviazione standard).\n\nFrequenza di taglio finale.\n\nDunque, per concludere, da un lato non è opportuno filtrare troppo tardi, poiché non verrebbe filtrato sufficientemente il rumore del segnale. Dall’altra, anticipare eccessivamente il taglio implica una distorsione dal segnale di riferimento, di cui un buon indicatore è la deviazione standard dei residui; questo fenomeno è dovuto a una soverchiante attenuazione di componenti in frequenza, magari proprie del segnale nominale stesso. Quindi, sulla base delle precedenti osservazioni, si sceglie una frequenza di taglio pari a \\(f_c = 7\\,\\mathrm{Hz}\\), ritenuta la più approssimativa del segnale ricostruito con Fourier."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Esercitazioni di esame",
    "section": "",
    "text": "Questo sito contiene la raccolta di esercitazioni da consegnare all’esame di Misure Industriali, del corso di Ingegneria Industriale, presso l’Università di Trento.\nLe esercitazioni fanno riferimento al sito relativo al corso di insegnamento.\npoi devo mettere le librerie in un htmle per vedere tutto formattata bene a codice\n\nQuesti riquadri servono a mettere in rilievo quando viene data risposta ai quesiti dell’esercitazione.\n\n\n1 Contenuti\n\nLibrerie:\n\ndig_signal_proc.R: funzioni relative al digital signal processing\ngraphics.R: funzioni relative alla formattazione della grafica\n\nEsercitazione 1 - Segnale di onda pressoria\nEsercitazione 2 - Modulaione di ampiezza\nEsercitazione 3 - Taratura dinamica tramite regressione non lineare\nEsercitazione 4 - Compensazione dinamica"
  },
  {
    "objectID": "ex2.html",
    "href": "ex2.html",
    "title": "Esercitazione 2",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie."
  },
  {
    "objectID": "ex2.html#modulazione",
    "href": "ex2.html#modulazione",
    "title": "Esercitazione 2",
    "section": "2.1 Modulazione",
    "text": "2.1 Modulazione\n\n# Onda portante: carrier &lt;- cos(2 * pi * fp * t)\n# Aggiungiamo alla struttura associata alla misura il segnale modulato:\nym &lt;- ym %&gt;% mutate(\n    yn_m = (1 + m * ym$yn) * cos(2 * pi * fp * t),\n    fft_m = fft(yn_m),\n    intensity_m = Mod(fft_m) / length(t)*2,\n    phase_m = Arg(fft_m)/pi*180\n  )\n\nym %&gt;% pivot_longer(\n    cols = c(yn, yn_m)\n  ) %&gt;% mutate(\n    name = factor(name, levels = c(\"yn_m\", \"yn\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(\n    \"yn_m\" = \"Modulato\",\n    \"yn\" = \"Misurato\"\n  )) +\n  labs(x = \"Tempo (s)\", y = \"Segnale\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\n\nplot_ly() %&gt;%\n  add_bars(data = ym, x = ~f, y = ~intensity, name = \"Segnale\", marker = list(color = \"blue\")) %&gt;%\n  add_bars(x = r$f, y = r$intensity, name = \"Rumore\", marker = list(color = \"red\")) %&gt;%\n  add_bars(data = ym, x = ~f, y = ~intensity_m, name = \"Segnale Modulato\", marker = list(color = \"green\")) %&gt;%\n  layout(title = \"Spettro di Intensità\",\n       xaxis = list(title = \"Frequenza (Hz)\", range = c(0, 500), showgrid = TRUE),\n       yaxis = list(title = \"Intensità\", showgrid = TRUE),\n       legend = list(x = 0.25, y = 0.9))"
  },
  {
    "objectID": "ex2.html#esposizione-del-segnale-modulato-al-rumore",
    "href": "ex2.html#esposizione-del-segnale-modulato-al-rumore",
    "title": "Esercitazione 2",
    "section": "2.2 Esposizione del segnale modulato al rumore",
    "text": "2.2 Esposizione del segnale modulato al rumore\n\n# Effetto interferente sul segnale modulato:\nym &lt;- ym %&gt;% mutate(\n    yn_m_n = yn_m + r$y,\n    fft_m = fft(yn_m_n),\n    intensity_m = Mod(fft_m) / length(t)*2,\n    phase_m = Arg(fft_m)/pi*180\n  )\n\nplot_ly() %&gt;%\n  add_lines(data = ym, x = ~f, y = ~intensity_m, type = \"bar\", name = \"Segnale\", marker = list(color= \"blue\")) %&gt;%\n  layout(title = \"Spettro segnale modulato affetto da rumore\",\n       xaxis = list(title = \"Frequenza (Hz)\", range = c(0, 500), showgrid = TRUE),\n       yaxis = list(title = \"Intensità\", showgrid = TRUE))\n\n\n\n\n\n\nplot_ly() %&gt;%\n  add_lines(data = ym, x = ~t, y = ~yn_m, name = \"Segnale modulato\") %&gt;%\n  add_lines(data = ym, x = ~t, y = ~yn_m_n, name = \"Con effetto interferente\") %&gt;%\n  layout(title = \"Segnale modulato affetto da rumore\", \n         xaxis = list(title = \"Tempo (s)\"), \n         yaxis = list(title = \"Segnale\"))"
  },
  {
    "objectID": "ex2.html#eliminazione-del-rumore-interferente",
    "href": "ex2.html#eliminazione-del-rumore-interferente",
    "title": "Esercitazione 2",
    "section": "3.1 Eliminazione del rumore interferente",
    "text": "3.1 Eliminazione del rumore interferente\nOsservando lo spettro del segnale modulato esposto al rumore interferente, è evidente come le componenti di rumore siano separate da quelle del segnale modulato, che si trova ad alta frequenza. Pertanto, può essere implementato un filtro digitale passa-alto offline per selezionare solo quello modulato.\n\nFiltro passa-alto.\n\nInizialmente è stato scelto un filtro Butterworth, il cui ordine e frequenza di taglio sono stati selezionati a tentativi, affinché attenuassero il più possibile l’ultima componente di rumore a 135 Hz senza ridurre eccessivamente il segnale modulato.\n\nf_cutoff &lt;- 200\nflt.butter &lt;- butter(4, f_cutoff/(fc/2), type = \"high\")  # filtro Butterworth passa-alto\n\nggbodeplot_digital(flt.butter, fc, fmin = 1e1) + geom_vline(xintercept = f_cutoff, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- tibble(\n  t = ym$t,\n  yn = ym$yn,\n  yn_m = ym$yn_m,\n  yn_m_n = ym$yn_m_n,\n  yn_m_n.flt = signal::filtfilt(flt.butter, yn_m_n),   # estrae il segnale modulato\n  f = 0:(length(t)-1)/max(t),\n  fft = fft(yn_m_n.flt),\n  intensity = Mod(fft)/length(t)*2,\n  phase = Arg(fft)*180/pi\n) \n\nym.flt %&gt;% dplyr::filter(f &lt;= fc/2) %&gt;% plot_ly(x = ~f) %&gt;%\n  add_lines(y = ~intensity) %&gt;%\n  layout(xaxis = list(title=\"Frequenza (Hz)\"), yaxis=list(title=\"Intensità\"), title=\"Filtraggio del segnale modulato con filtro Butterworth\")\n\n\n\n\n\nTuttavia, nello spettro compare ancora una componente di rumore e il segnale in banda trasmessa risulta leggermente attenuato. Dunque, viene implementato un filtro di tipo Chebishev II, il quale a parità di ordine del Butterfly possiede una banda di transizione più ripida. Questo genere di filtro introdurrà un ripple in banda di stop, che però verrà attenuato mediante un filtraggio delle basse frequenze, che è richiesto per eliminare il rumore bianco. Nello specifico, a tentativi è stato scelto un taglio pari alla componente di più alta frequenza del rumore interferente.\n\nf_cutoff &lt;- max(pars_r$f)\nflt.cheby &lt;- cheby2(4, 20, f_cutoff/(fc/2), type = \"high\")  # N.B.: 20dB di riduzione del ripple in stop band\n\nggbodeplot_digital(flt.cheby, fc, fmin = 1e1) + geom_vline(xintercept = f_cutoff, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- ym.flt %&gt;% mutate(\n  yn_m_n.flt = signal::filtfilt(flt.cheby, yn_m_n),   # estrae il segnale modulato\n  f = 0:(length(t)-1)/max(t),\n  fft = fft(yn_m_n.flt),\n  intensity = Mod(fft)/length(t)*2,\n  phase = Arg(fft)*180/pi\n) \n\nym.flt %&gt;% dplyr::filter(f &lt;= fc/2) %&gt;% plot_ly(x = ~f) %&gt;%\n  add_lines(y = ~intensity) %&gt;%\n  layout(xaxis = list(title=\"Frequenza (Hz)\"), yaxis=list(title=\"Intensità\"), title=\"Filtraggio del segnale modulato con filtro Chebyshev II\")\n\n\n\n\n\nInfatti, ora lo spettro mostra il rumore essere quasi inesistente e il segnale trasmesso quasi privo di attenuazione.\n\nym.flt %&gt;% plot_ly(x = ~t) %&gt;%\n  add_lines(y = ~yn_m_n, name = \"Con rumore interferente\") %&gt;%\n  add_lines(y = ~yn_m, name = \"Modulato\") %&gt;%\n  add_lines(y = ~yn_m_n.flt, name = \"Filtrato\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"Segnale\"), title = \"Estrazione del segnale modulato\")\n\n\n\n\n\nA conferma del corretto procedimento di filtraggio è il fatto che il segnale ottenuto corrisponde a quello modulato prima dell’esposizione al rumore."
  },
  {
    "objectID": "ex2.html#demodulazione",
    "href": "ex2.html#demodulazione",
    "title": "Esercitazione 2",
    "section": "3.2 Demodulazione",
    "text": "3.2 Demodulazione\n\nDemodulazione.\n\nIl processo di demodulazione è quello che permette di separare il segnale misurato dalla portante. A tal fine, viene scelta la demodulazione sincrona [suggerimento ChatGPT], in cui il segnale modulato viene moltiplicato per un’armonica pura con stessa frequenza e fase della portante (per questo si chiama “sincrona”). Nello specifico, i passaggi da seguire sono i seguenti:\n\n:\n\n\\[\\begin{aligned}\ny_{mix} :&= y_{mod}(t) \\cdot \\cos(2\\pi f_p t) \\\\\n&= (1 + m y(t)) \\cos^2(2\\pi f_p t) \\\\\n&= (1+my(t))\\frac{1+\\cos(4\\pi f_p t)}{2} \\\\\n&= \\frac{1}2 (1+m y(t)) + \\frac{1}2 (1+my(t))\\cos(4 \\pi f_p t) .\n\\end{aligned}\\]\n\nFiltraggio passa-basso: il segnale ottenuto dal mixing è caratterizzato da una componente a bassa frequenza (pari al più a \\(f_{max}\\) del segnale misurato) ed una ad alta frequenza (pari a \\(2f_p\\)): \\[\nLP\\{y_{mix}\\}(f_{max} &lt; f_{cutoff} \\ll 2f_p) \\longrightarrow y_{flt} \\approx 1+my(t) .\n\\]\nRielaborazione matematica per ottenere il segnale misurato:\n\n\\[\n\\frac{1}m (y_{flt} - 1) = y(t) .\n\\]\nIn particolare, il filtro passa-basso permette anche di attenuare il ripple dal filtro Chebyshev e il rumore bianco.\n\nym.flt &lt;- ym.flt %&gt;% select(-fft, -intensity, -phase, -f) %&gt;% mutate(\n  y_mix = (2*yn_m_n.flt*cos(2*pi*fp*t) - 1)/m   # demodulazione + rielaborazione matematica\n)\n\n# Filtro passa-basso\n# Taglio al doppio della freq. max del segnale misurato\n# per far passare l'intero suo spettro\nf_cut2 &lt;- 2*max(pars_m$f)\nflt.butter.lp &lt;- butter(2, f_cut2/(fc/2))\n\nggbodeplot_digital(flt.butter.lp, fc, fmin = 1) + geom_vline(xintercept = f_cut2, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- ym.flt %&gt;% mutate(\n  y_flt2 = filtfilt(flt.butter.lp, y_mix)\n)\n\nym.flt %&gt;% plot_ly(x = ~t) %&gt;%\n  add_lines(y = ~yn_m_n.flt, name = \"Filtrato\") %&gt;%\n  add_lines(y = ~y_flt2, name = \"Demodulato\") %&gt;%\n  layout(xaxis = list(title=\"Tempo (s)\"), yaxis=list(title=\"Segnale\"), title = \"Demodulazione\")\n\n\n\n\n\n\nComparazione con la misura originale.\n\n\nym.flt %&gt;% pivot_longer(cols = c(\"yn\", \"y_flt2\")) %&gt;%\n  mutate(\n    name = factor(name, levels = c(\"yn\", \"y_flt2\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(yn = \"Originale\", y_flt2 = \"Demodulato\")) +\n  labs(x = \"Tempo (s)\", y = \"Segnale\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\nSi osservi come il processo di demodulazione ha permesso anche di filtrare il rumore."
  },
  {
    "objectID": "ex4.html",
    "href": "ex4.html",
    "title": "Esercitazione 4",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie."
  },
  {
    "objectID": "ex4.html#spettro-dei-segnali-misurati",
    "href": "ex4.html#spettro-dei-segnali-misurati",
    "title": "Esercitazione 4",
    "section": "2.1 Spettro dei segnali misurati",
    "text": "2.1 Spettro dei segnali misurati\n\nTa &lt;- max(u$t)\nun.fft &lt;- compute_fft(tmp, Ta, un)\nideal.fft &lt;- compute_fft(tmp, Ta, ideal)\nout.fft &lt;- compute_fft(tmp, Ta, out)\n\nbind_rows(\n  un.fft %&gt;% mutate(caso = \"Input\"),\n  ideal.fft %&gt;% mutate(caso = \"Output ideale\"),\n  out.fft %&gt;% mutate(caso = \"Output\")\n) %&gt;% dplyr::filter(f &lt; 1) %&gt;% \n  ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(angle = pi/2, y=0, radius = mod), linewidth = 0.2, colour = \"#F8766D\") +\n  geom_point(colour = \"#F8766D\") +\n  facet_wrap(~ caso, ncol = 1, scales = \"free_x\") +\n  labs(\n    x = \"Frequenza (Hz)\",\n    y = \"Intensità\"\n  )\n\n\n\n\n\n\n\n\nNB: non si vede, ma il rumore bianco è presente. Provare ad ingrandire la dev. std. del rumore addizionato a un."
  }
]