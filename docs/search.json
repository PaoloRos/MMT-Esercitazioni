[
  {
    "objectID": "ex2.html",
    "href": "ex2.html",
    "title": "Esercitazione 2",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie."
  },
  {
    "objectID": "ex2.html#modulazione",
    "href": "ex2.html#modulazione",
    "title": "Esercitazione 2",
    "section": "2.1 Modulazione",
    "text": "2.1 Modulazione\n\n# Onda portante: carrier &lt;- cos(2 * pi * fp * t)\n# Aggiungiamo alla struttura associata alla misura il segnale modulato:\nym &lt;- ym %&gt;% mutate(\n    yn_m = (1 + m * ym$yn) * cos(2 * pi * fp * t),\n    fft_m = fft(yn_m),\n    intensity_m = Mod(fft_m) / length(t)*2,\n    phase_m = Arg(fft_m)/pi*180\n  )\n\nym %&gt;% pivot_longer(\n    cols = c(yn, yn_m)\n  ) %&gt;% mutate(\n    name = factor(name, levels = c(\"yn_m\", \"yn\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(\n    \"yn_m\" = \"Modulato\",\n    \"yn\" = \"Misurato\"\n  )) +\n  labs(x = \"Tempo (s)\", y = \"Segnale (c.u.)\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\n\nplot_ly() %&gt;%\n  add_bars(data = ym, x = ~f, y = ~intensity, name = \"Segnale\", marker = list(color = \"blue\")) %&gt;%\n  add_bars(x = r$f, y = r$intensity, name = \"Rumore\", marker = list(color = \"red\")) %&gt;%\n  add_bars(data = ym, x = ~f, y = ~intensity_m, name = \"Segnale Modulato\", marker = list(color = \"green\")) %&gt;%\n  layout(title = \"Spettro di Intensità\",\n       xaxis = list(title = \"Frequenza (Hz)\", range = c(0, 500), showgrid = TRUE),\n       yaxis = list(title = \"Intensità\", showgrid = TRUE),\n       legend = list(x = 0.25, y = 0.9))"
  },
  {
    "objectID": "ex2.html#esposizione-del-segnale-modulato-al-rumore",
    "href": "ex2.html#esposizione-del-segnale-modulato-al-rumore",
    "title": "Esercitazione 2",
    "section": "2.2 Esposizione del segnale modulato al rumore",
    "text": "2.2 Esposizione del segnale modulato al rumore\n\n# Effetto interferente sul segnale modulato:\nym &lt;- ym %&gt;% mutate(\n    yn_m_n = yn_m + r$y,\n    fft_m = fft(yn_m_n),\n    intensity_m = Mod(fft_m) / length(t)*2,\n    phase_m = Arg(fft_m)/pi*180\n  )\n\nplot_ly() %&gt;%\n  add_lines(data = ym, x = ~f, y = ~intensity_m, type = \"bar\", name = \"Segnale\", marker = list(color= \"blue\")) %&gt;%\n  layout(title = \"Spettro segnale modulato affetto da rumore\",\n       xaxis = list(title = \"Frequenza (Hz)\", range = c(0, 500), showgrid = TRUE),\n       yaxis = list(title = \"Intensità\", showgrid = TRUE))\n\n\n\n\n\n\nplot_ly() %&gt;%\n  add_lines(data = ym, x = ~t, y = ~yn_m, name = \"Segnale modulato\") %&gt;%\n  add_lines(data = ym, x = ~t, y = ~yn_m_n, name = \"Con effetto interferente\") %&gt;%\n  layout(title = \"Effetto interferente\", \n         xaxis = list(title = \"Tempo (s)\"), \n         yaxis = list(title = \"Ampiezza\"))"
  },
  {
    "objectID": "ex2.html#eliminazione-del-rumore-interferente",
    "href": "ex2.html#eliminazione-del-rumore-interferente",
    "title": "Esercitazione 2",
    "section": "3.1 Eliminazione del rumore interferente",
    "text": "3.1 Eliminazione del rumore interferente\nOsservando lo spettro del segnale modulato esposto al rumore interferente, è intuitivo pensare di dover selezionare solo le frequenze che costituiscono il segnale modulato.\n\nFiltro passa-alto.\n\nPertanto viene realizzato un filtro passa-alto, in cui la frequenza di taglio viene scelta visivamente in base allo spettro: \\(f_c = 250\\,\\mathrm{Hz}\\) –&gt; dovrebbe far passare solo il segnale modulato\ncutoff filtro a tentativi –&gt; quello che taglia di più il rumore ma non attenua eccessivamente il modulato\n\nf_cutoff &lt;- 200\nflt.butter &lt;- butter(4, f_cutoff/(fc/2), type = \"high\")  # filtro butterfly passa-alto\n\nggbodeplot_digital(flt.butter, fc, fmin = 1e1) + geom_vline(xintercept = f_cutoff, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- tibble(\n  t = ym$t,\n  yn = ym$yn,\n  yn_m = ym$yn_m,\n  yn_m_n = ym$yn_m_n,\n  yn_m_n.flt = signal::filtfilt(flt.butter, yn_m_n),   # estrae il segnale modulato\n  f = 0:(length(t)-1)/max(t),\n  fft = fft(yn_m_n.flt),\n  intensity = Mod(fft)/length(t)*2,\n  phase = Arg(fft)*180/pi\n) \n\nym.flt %&gt;% dplyr::filter(f &lt;= fc/2) %&gt;% plot_ly(x = ~f) %&gt;%\n  add_lines(y = ~intensity) %&gt;%\n  layout(xaxis = list(title=\"Frequenza (Hz)\"), yaxis=list(title=\"Intensità\"), title=\"Filtraggio del segnale modulato con filtro Butterworth\")\n\n\n\n\n\nrumore interferente ha una componente troppo vicina alla parte modulata -&gt; lo attenuo, ma attenuo anche il segnale. Sluzione:\n\naumentare ordine del filtro -&gt; ma non si riesce ad attenuare sufficientemente\naumentare fcutoff –&gt; mi avvicino troppo alle componente del segnale modulato, attenuandolo così (perdo informazione)\n\nUso un altro tipo di filtro, con banda di transizione più ristretta (taglio più netto): Chebyshev II (sempre IIR)-&gt; transition band più brusca del butterfly a parità di ordine, ma introduce ripple in stop band –&gt; la andro a filtrare successivamente assieme al rumore bianco\nDalla funzione di rf mi rendo conto che posso usare un cutoff pari alla componente a freq. massima del rumore interferente\n\nf_cutoff &lt;- max(pars_r$f)\nflt.cheby &lt;- cheby2(4, 20, f_cutoff/(fc/2), type = \"high\")  # N.B.: 20dB di riduzione del ripple in stop band\n\nggbodeplot_digital(flt.cheby, fc, fmin = 1e1) + geom_vline(xintercept = f_cutoff, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- ym.flt %&gt;% mutate(\n  yn_m_n.flt = signal::filtfilt(flt.cheby, yn_m_n),   # estrae il segnale modulato\n  f = 0:(length(t)-1)/max(t),\n  fft = fft(yn_m_n.flt),\n  intensity = Mod(fft)/length(t)*2,\n  phase = Arg(fft)*180/pi\n) \n\nym.flt %&gt;% dplyr::filter(f &lt;= fc/2) %&gt;% plot_ly(x = ~f) %&gt;%\n  add_lines(y = ~intensity) %&gt;%\n  layout(xaxis = list(title=\"Frequenza (Hz)\"), yaxis=list(title=\"Intensità\"), title=\"Filtraggio del segnale modulato con filtro Chebychev 2\")\n\n\n\n\n\neliminato componenti rumore interferente\nettenuazione del modulato molto ridotta\n\nym.flt %&gt;% plot_ly(x = ~t) %&gt;%\n  add_lines(y = ~yn_m_n, name = \"Con rumore interferente\") %&gt;%\n  add_lines(y = ~yn_m, name = \"Modulato\") %&gt;%\n  add_lines(y = ~yn_m_n.flt, name = \"Filtrato\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"Segnale\"), title = \"Estrazione del segnale modulato\")\n\n\n\n\n\nVisivamente si vede che i due segnali coincidono."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Esercitazioni di esame",
    "section": "",
    "text": "Questo sito contiene la raccolta di esercitazioni da consegnare all’esame di Misure Industriali, del corso di Ingegneria Industriale, presso l’Università di Trento.\nLe esercitazioni fanno riferimento al sito relativo al corso di insegnamento.\npoi devo mettere le librerie in un htmle per vedere tutto formattata bene a codice\n\nQuesti riquadri servono a mettere in rilievo quando viene data risposta ai quesiti dell’esercitazione.\n\n\n1 Contenuti\n\nLibrerie:\n\ndig_signal_proc.R: funzioni relative al digital signal processing\ngraphics.R: funzioni relative alla formattazione della grafica\n\nEsercitazione 1 - Segnale di onda pressoria\nEsercitazione 2 - Modulaione di ampiezza"
  },
  {
    "objectID": "ex1.html",
    "href": "ex1.html",
    "title": "Esercitazione 1",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie.\nParametri di campionamento che verranno considerati nell’analisi:\n# Campionamento regolare\nfs &lt;- 1000      # freq. di campionamento\nTs &lt;- 1/fs      # periodo di campionamento"
  },
  {
    "objectID": "ex1.html#ricostruzione-mediante-serie-di-fourier",
    "href": "ex1.html#ricostruzione-mediante-serie-di-fourier",
    "title": "Esercitazione 1",
    "section": "1.1 Ricostruzione mediante serie di Fourier",
    "text": "1.1 Ricostruzione mediante serie di Fourier\nIl segnale viene ricostruito mediante le serie di Fourier, in cui l’\\(n\\)-esimo elemento vale:\n\\[\np[n] = a_0 + \\sum_{k = 1}^{K} a_k \\cos[2\\pi k f_0 \\, n] + \\sum_{k = 1}^{K} a_k \\sin[2\\pi k f_0  \\, n] ,\n\\]\ndove \\(f_0\\) è la frequenza fondamentale, \\(K\\) è il numero totale di componenti armoniche e \\(a_k, b_k\\) sono le \\(k\\)-esime componenti, risultato della scomposizione su basi orto-normali. Si osservi che la componente in DC non viene divisa per 2, perché è calcolata come la media del segnale, anziché il doppio della media (come da teoria della trasformata).\nLa \\(k\\)-esima componente avrà frequenza pari a \\(f_k = k f_0 = \\frac{k}{T_a}\\), dove \\(T_a = 10\\,\\mathrm{s}\\) è il tempo di acquisizione. Perciò, in virtù del Teorema di Nyquist-Shannon, deve valere la seguente disuguaglianza, per la quale si calcola la massima componente:\n\\[\nf_{max} = \\frac{k_{max}}{T_a} \\leq \\frac{f_s}2 \\Leftrightarrow k_{max} = \\frac{f_s T_a}{2} = 5000,\n\\] con \\(f_s = 1000\\,\\mathrm{Hz}\\) la frequenza di campionamento.\n\nRicostruzione segnale anche con i coseni.\n\n\na0 &lt;- mean(sig_art$p_art)\n\n# La componente DC è ortogonale alle basi seno e cose\n# Per evitare errori numerici, quest'ultima viene sottratta al segnale\np_art_osc &lt;- sig_art$p_art - a0\n\nK &lt;- 500 # massimo possibile: 5e3\nf_fund &lt;- 1/Ta\n\ncomps_cos &lt;- map_dbl(1:K, \\(k) {\n  c &lt;- cos_k(sig_art$t, f_fund, k)\n  p_art_osc %ps% c/norm_ps(c)\n}) %&gt;% zapsmall()\n\ncomps_sin &lt;- map_dbl(1:K, \\(k) {\n  s &lt;- sin_k(sig_art$t, f_fund, k)\n  p_art_osc %ps% s/norm_ps(s)\n}) %&gt;% zapsmall()\n\ncomps_sin[1:50]\n\n [1]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n [8]  0.000000  0.000000  9.340245  0.000000  0.000000  0.000000  0.000000\n[15]  0.000000  0.000000  0.000000  0.000000  0.000000  3.153407  0.000000\n[22]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n[29]  0.000000  3.164646  0.000000  0.000000  0.000000  0.000000  0.000000\n[36]  0.000000  0.000000  0.000000  0.000000  1.965583  0.000000  0.000000\n[43]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n[50] -0.061118\n\n\n\nRoutine mediante reduce.\n\n\n# Implementazione mediante reduce\nsig_art &lt;- sig_art %&gt;% mutate(\n  p_art_k = a0 + reduce(1:K, \\(acc, k) {\n    c &lt;- cos_k(t, f_fund, k)\n    s &lt;- sin_k(t, f_fund, k)\n    acc + comps_cos[k] * c/norm_ps(c) + comps_sin[k] * s/norm_ps(s)\n  }, .init = rep(0, n()))\n)\n\nplot_ly() %&gt;%\n  add_lines(x = sig_art$t, y = sig_art$p_art, name = \"Originale\") %&gt;%\n  add_lines(x = sig_art$t, y = sig_art$p_art_k, name = \"Ricostruito\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"Pressione (mmHg)\"), title = \"Ricostruzione del segnale\")"
  },
  {
    "objectID": "ex1.html#analisi-statica",
    "href": "ex1.html#analisi-statica",
    "title": "Esercitazione 1",
    "section": "3.1 Analisi statica",
    "text": "3.1 Analisi statica\n\nAnalisi statica dei residui.\n\n\n# Traslo il tempo a 0: fa comodo partire da lì\np.flt_5Hz &lt;- p.flt_5Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;%  \n  mutate(eps = p_k - p_flt)\n\np.flt_2Hz &lt;- p.flt_2Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;% \n  mutate(eps = p_k - p_flt)\n\np.flt_7Hz &lt;- p.flt_7Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;% \n  mutate(eps = p_k - p_flt)\n\nbind_rows(\n  p.flt_2Hz %&gt;% mutate(case = \"2 Hz\"),\n  p.flt_5Hz %&gt;% mutate(case = \"5 Hz\"),\n  p.flt_7Hz %&gt;% mutate(case = \"7 Hz\")\n) %&gt;% pivot_longer(\n  cols = c(p_k, p_flt)\n) %&gt;% mutate(\n    name = factor(name, levels = c(\"p_k\", \"p_flt\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(\n    \"p_k\" = \"Ricostruito\",\n    \"p_flt\" = \"Filtrato\"\n  )) +\n  facet_wrap(~ case, ncol = 1, scales = \"free_x\") +\n  labs(x = \"Tempo (s)\", y = \"Pressione (mmHg)\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\n\nbind_rows(\n  p.flt_2Hz %&gt;% mutate(caso = \"2 Hz\"),\n  p.flt_5Hz %&gt;% mutate(caso = \"5 Hz\"),\n  p.flt_7Hz %&gt;% mutate(caso = \"7 Hz\")\n) %&gt;% ggplot(aes(x = t, y = eps, colour = caso)) +\n  geom_point(size = 0.6, alpha = 0.6) +\n  labs(x = \"Tempo (s)\", y = \"Residui (mmHg)\", colour = latex2exp::TeX(\"$f_c\"))\n\n\n\n\n\n\n\n\nDai grafici soprastanti è evidente come anticipare il taglio distorga il segnale da quello di riferimento."
  },
  {
    "objectID": "ex1.html#analisi-in-frequenza",
    "href": "ex1.html#analisi-in-frequenza",
    "title": "Esercitazione 1",
    "section": "3.2 Analisi in frequenza",
    "text": "3.2 Analisi in frequenza\n\nAnalisi in frequenza dei residui.\n\n\n# Funzione per automatizzare il calcolo dello spettro\ncompute_fft &lt;- function(df, Ta, N, name_sig, monolateral = TRUE) {\n  \n  df &lt;- df %&gt;% mutate(\n    f = n/Ta,\n    fft = fft({{ name_sig }}),\n    mod = ifelse(monolateral, (2-(f==0)), 1) * Mod(fft) / length(n),\n    phase = Arg(fft)/pi*180\n  )\n  \n  if(monolateral)\n    return(df %&gt;% slice_head(n = floor(N/2)))\n  \n  df\n}\n\n\n# Nuovo tempo di campionamento (a causa dell'eliminazione delle code)\nTa &lt;- max(p.flt_2Hz$t) + 1/fs\nN &lt;- length(p.flt_2Hz$n)\n\n# Spettro dei segnali senza la componenti a f=0\np.flt_2Hz.fft &lt;- compute_fft(p.flt_2Hz, Ta, N, eps) %&gt;% slice(-1)\np.flt_5Hz.fft &lt;- compute_fft(p.flt_5Hz, Ta, N, eps) %&gt;% slice(-1)\np.flt_7Hz.fft &lt;- compute_fft(p.flt_7Hz, Ta, N, eps) %&gt;% slice(-1)\n\nbind_rows(\n  p.flt_2Hz.fft %&gt;% mutate(caso = \"2 Hz\"),\n  p.flt_5Hz.fft %&gt;% mutate(caso = \"5 Hz\"),\n  p.flt_7Hz.fft %&gt;% mutate(caso = \"7 Hz\")\n) %&gt;% dplyr::filter(f &lt; 50) %&gt;% \n  ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(angle = pi/2, y=0, radius = mod), linewidth = 0.2, colour = \"#F8766D\") +\n  geom_point(colour = \"#F8766D\") +\n  facet_wrap(~ caso, ncol = 1, scales = \"free_x\") +\n  labs(\n    x = \"Frequenza (Hz)\",\n    y = \"Ampiezza Residui (mmHg)\",\n    title = \"Spettri dei segnali filtrati\"\n  )\n\n\n\n\n\n\n\n\n\ntmp &lt;- list(fc_2 = p.flt_2Hz, fc_5 = p.flt_5Hz, fc_7 = p.flt_7Hz)\n\nstats &lt;-  tibble(\n  fc = c(\"2 Hz\", \"5 Hz\", \"7 Hz\"),\n  mean = map_dbl(tmp, ~ mean(.x$eps)),\n  sd = map_dbl(tmp, ~ sd(.x$eps))\n)\n\nknitr::kable(stats, digits = 2, caption = \"Statistiche dei residui\")\n\n\nStatistiche dei residui\n\n\nfc\nmean\nsd\n\n\n\n\n2 Hz\n0.10\n6.01\n\n\n5 Hz\n0.00\n1.72\n\n\n7 Hz\n-0.02\n0.70\n\n\n\n\n\nAnche osservando lo spettro dei residui è chiaro come avere una frequenza di taglio troppo bassa porti ad allontanarsi dall’andamento nominale. Infatti la dispersione dei residui tende ad aumentare (si guardi al valore di deviazione standard).\n\nFrequenza di taglio finale.\n\nDunque, per concludere, da un lato non è opportuno filtrare troppo tardi, poiché non verrebbe filtrato sufficientemente il rumore del segnale. Dall’altra, anticipare eccessivamente il taglio implica una distorsione dal segnale di riferimento, di cui un buon indicatore è la deviazione standard dei residui; questo fenomeno è dovuto a una soverchiante attenuazione di componenti in frequenza, magari proprie del segnale nominale stesso. Quindi, sulla base delle precedenti osservazioni, si sceglie una frequenza di taglio pari a \\(f_c = 7\\,\\mathrm{Hz}\\), ritenuta la più approssimativa del segnale ricostruito con Fourier."
  }
]