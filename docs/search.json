[
  {
    "objectID": "dsp_library.html",
    "href": "dsp_library.html",
    "title": "Libreria Digital Signal Processing",
    "section": "",
    "text": "# This file contains some main function related to the digital signal processing\n\n# --- Signal operations ---\n\n# Scalar product\n`%ps%` &lt;- function(a, b) mean(a*b)\n\n# Norm of a vector\nnorm_ps &lt;- function(a) sqrt(a %ps% a)\n\n# Scalar normalized product between n decimated vectors: i.e. cosine similarity\npsDnN &lt;- function(a, b, n = 1) {\n  stopifnot(n &gt;= 1, n %% 1 == 0)\n  \n  idx &lt;-  seq(1, min(length(a), length(b)), by = n)\n  \n  a_d &lt;- a[idx]\n  b_d &lt;- b[idx]\n  \n  mean(a_d * b_d) / (norm_ps(a_d)*norm_ps(b_d))\n}\n\n# --- Fourier Transform ---\n\n# Harmonic components\ncos_k &lt;- function(t, f, k=1) cos(2*pi*f*k*t)\nsin_k &lt;- function(t, f, k=1) sin(2*pi*f*k*t)\n\ncompute_fft &lt;- function(df, Ta, name_sig, monolateral = TRUE) {\n  \n  # Compute the FFT of a signal\n  # df: data frame\n  # Ta: acquisition time\n  # name_sig: name of the signal contained in `df`\n  \n  N &lt;- nrow(df)\n  \n  df &lt;- df %&gt;% mutate(\n    n = row_number(),\n    f = n/Ta,\n    fft = fft({{ name_sig }}),\n    mod = ifelse(monolateral, (2-(f==0)), 1) * Mod(fft) / length(n),\n    phase = Arg(fft)/pi*180\n  )\n  \n  if(monolateral)\n    return(df %&gt;% slice_head(n = floor(N/2)))\n  \n  df\n}\n\n# Upgraded version of `compute_fft`\nspectrum_fft &lt;- function(df, fs = NULL, name_sig, monolateral = TRUE, DC = TRUE) {\n  \n  # Compute the spectrum of a signal using FFT\n  # df: signal data frame, it's required the time `t` vector!\n  # fs: sampling frequency, it's required a uniform sampling!\n  # name_sig: name of the signal contained in `df`. Must be a string!\n  # monolateral: defines whether monolateral or bilateral spectrum\n  # DC: defines whether consider or not the DC component\n  \n  # Note aboute the scale factor of the module:\n  # To preserve the energy content, when the spectrum is monolateral\n  # it's needed to double the module of the trasform, excluding\n  # DC component and component at Nyquist frequency\n  \n  if (!is.character(name_sig) || length(name_sig) != 1 || nchar(name_sig) == 0)\n    stop(\"`name_sig` must be a non-empty string of length 1.\")\n  \n  if (!name_sig %in% names(df))\n    stop(sprintf(\"Column '%s' not found in data frame.\", name_sig))\n  \n  \n  N &lt;- nrow(df)\n  \n  if (is.null(fs)) {\n    dt &lt;- diff(df$t)\n    dt_mean &lt;- mean(dt)\n    \n    if (sd(dt) / dt_mean &gt; 1e-6) {\n      stop(\"Non-uniform sampling detected.\")\n    }\n    \n    fs &lt;- 1 / dt_mean\n  }\n  \n  out &lt;- df %&gt;% mutate(\n    k = 0:(N-1),\n    f = k*fs/N,\n    fft = fft(df[[name_sig]]),\n    mod = Mod(fft) / N * if (monolateral) {           # scale factor\n      ifelse(k == 0 | (N %% 2 == 0 & k == N/2), 1, 2)\n    } else {\n      1\n    },\n    phase = Arg(fft)/pi*180\n  )\n  if(!DC)\n    out &lt;- out[-1,]\n  \n  if(monolateral)\n    return(out %&gt;% slice_head(n = floor(N/2) + 1))\n  \n  return(out)\n}\n\ndyn_compensation &lt;- function(df, tf, name_sig = \"y\", padding = TRUE, alpha = 2) {\n  \n  # This function provides the dynamic compensation of an\n  # LTI proper system\n  \n  # df: contains the signal(t, `name_sig`)\n  # alpha: scale factor of padding\n  # tf: transfer function, it must be a class `tf`\n  \n  if (!is.character(name_sig) || length(name_sig) != 1 || nchar(name_sig) == 0)\n    stop(\"`name_sig` must be a non-empty string of length 1.\")\n  \n  if (!name_sig %in% names(df))\n    stop(sprintf(\"Column '%s' not found in data frame.\", name_sig))\n  \n  # Sampling parameters\n  dt &lt;- diff(df$t)\n  Ts &lt;- mean(dt)            # sampling period\n  \n  if (sd(dt) / Ts &gt; 1e-6) \n    stop(\"Non-uniform sampling detected.\")\n  \n  fs &lt;- 1 / Ts              # sampling frequency\n  \n  y &lt;- df[[name_sig]]\n  \n  if(padding) {\n    N &lt;- nrow(df)\n    M &lt;- alpha*N            # padding length\n    \n    pad_left  &lt;- floor((M - N)/2)\n    pad_right &lt;- ceiling((M - N)/2)\n    t_start &lt;- df$t[1] - pad_left * Ts\n    \n    out &lt;- tibble(\n      t = seq(from = t_start, by = Ts, length.out = M),\n      y = c(\n        rep(0, pad_left),\n        y,\n        rep(0, pad_right)\n      )\n    )\n    \n    stopifnot(isTRUE(all.equal(           # checks whether the signal is centered after padding\n      out$y[(pad_left+1):(pad_left+N)],\n      y,\n      tolerance = 1e-10\n      )))\n  }\n  \n  freq &lt;- tibble(\n    k = 0:(M-1),\n    f = ifelse(k &lt;= M/2, k, k-M) * fs/M,   # FFT is symmetric respect to the frequency!\n    w = 2*pi*f\n  )\n  \n  Hiw &lt;- freqresp(H, freq$w)\n  \n  out &lt;- out %&gt;% mutate(\n    Y = fft(y),\n    U = Y/Hiw,\n    u = Re(fft(U, inverse = TRUE)) / M      # Re() to avoid numerical residuals in Im() component\n                                            # fft() is not normalized, so it's divided by `M`\n  )\n  \n  return(out[ (pad_left+1):(pad_left+N), ])\n}\n\n# --- Filters ---\n\ngaussian_kernel &lt;- function(\n    x, sigma, radius = ceiling(3 * sigma), pad = c(\"none\", \"replicate\", \"reflect\")\n    ) {\n  \n  # Gaussian mask: law-pass filter, FIR and linear\n  # sigma: number of samples to consider in the gauss. kernel\n  \n  stopifnot(is.numeric(x), length(x) &gt; 0, is.numeric(sigma), sigma &gt; 0)\n  pad &lt;- match.arg(pad)\n  \n  # Kernels calculation\n  k &lt;- seq(-radius, radius)\n  h &lt;- exp(-(k^2) / (2 * sigma^2))\n  h &lt;- h / sum(h)  \n  \n  if (pad == \"none\") {\n    y &lt;- stats::filter(x, h, sides = 2) # convolution\n    return(as.numeric(y))\n  }\n  \n  # Padding of signal tails\n  if (pad == \"replicate\") {\n    x_pad &lt;- c(rep(x[1], radius), x, rep(x[length(x)], radius))\n  } else { # reflect\n    \n    left  &lt;- rev(x[2:(radius + 1)])\n    right &lt;- rev(x[(length(x) - radius):(length(x) - 1)])\n    x_pad &lt;- c(left, x, right)\n  }\n  \n  # Convolution and truncation of the excess tails\n  y_pad &lt;- stats::filter(x_pad, h, sides = 2)\n  y &lt;- y_pad[(radius + 1):(radius + length(x))]\n  \n  as.numeric(y)\n}"
  },
  {
    "objectID": "ex5.html",
    "href": "ex5.html",
    "title": "Esercitazione 5",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie.\n\n1 Funzioni\n\n# FUNZIONE: Generazione segnale sinusoidale con diverse armoniche\nsignal &lt;- function(t, pars, rad = FALSE) { \n  stopifnot(is.data.frame(pars))\n  with(pars, {\n    if (!rad) {\n      phi &lt;- phi/180*pi\n      f &lt;- 2*pi*f\n    }\n    map_dbl(t, \\(t) sum( map_vec(seq_along(w) , \\(i) w[i]*cos(t*f[i] + phi[i] ))))\n  })\n}\n\n\n\n2 Segnale d’ingresso\n\nf0 &lt;- 10\n\n# Provare con un'armonica pura\n# pars &lt;- tibble(\n#   w = c(1),\n#   f = c(f0),  # 1 funziona\n#   phi = c(0)\n# )\n\n# Provare con tante armoniche\npars &lt;- tibble(\n  w = c(1, 0.1, 0.3),\n  f = c(15, 20, 45),\n  phi = c(0, 0, 0)\n)\n\nN &lt;- 1000   # dimensione del campione\nfs &lt;- 1000  # freq. di campionamento\n\ns &lt;- tibble(\n  t = 0:N / fs, # 1 kHz di frequenza di campionamento\n  u = signal(t, pars), \n  u_n = u + rnorm(length(t), 0, pars$w[1] / 10)\n)\n\n\n\n\n\n\n\n\n\n\n\n\n3 FdT del sistema di isolamento\n\nM &lt;- 10\nK &lt;- 1000\nC &lt;- 50\n\n# Frequenza naturale:\nfn &lt;- 1/(2*pi) * sqrt(K/M)\n\nnum &lt;- c(C, K)\nden &lt;- c(M, C, K)\n\nH &lt;- tf(num, den)\n\nggbodeplot_continous(H, fs, fmin=0.1, fmax=100) +\n  geom_vline(xintercept=c(1, sqrt(2)) * fn, color=\"red\", linetype=2) +\n  labs(title=paste(\n    \"Natural frequency:\", round(fn, 2), \"Hz\",\n    \" - Isolation: &gt;\", round(sqrt(2)*fn, 2), \"Hz\"))\n\n\n\n\n\n\n\n\n\n\n4 Simulazione dell’uscita\n\noutput &lt;- lsim(H, s$u_n, s$t)\ns &lt;- s %&gt;% \n  mutate(\n    # Simulazione dell'uscita\n    y = output$y[1,]\n  )\n\n# Grafici\nplot_ly() %&gt;%\n  add_lines(x = s$t, y = s$u_n, name = \"Input\") %&gt;%\n  add_lines(x = s$t, y = s$y, name = \"Output\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"\"), title = \"Input & Output\")\n\n\n\n\n\n\n\n5 Ricostruzione dell’ingresso\n\nStima dell’ingresso a partire da uscita del sistema e da modulo e fase della FdT.\n\nR è in grado di operare nel domino complesso, perciò viene effettuata la compensazione dell’ingresso nel dominio della frequenza, come in Esercitazione 4. Nello specifico, mediante la funzione di libreria dyn_compensation vengono essenzialmente svolti i segueni passaggi, presupponendo un’opportuno segnale d’uscita passatogli come parametro:\n\neventuale padding, impostato dall’utente, per garantire la completa periodicità del segnale;\ncalcolo dalla FFT del segnale d’uscita e valutazione numerica della risposta in frequenza della FdT;\ninversione della caratteristica dinamica;\nFFT inversa che calcola l’ingresso nel dominio del tempo.\n\nPer effettuare la compensazione, è bene prendere atto che l’FdT inversa è un passa-alto:\n\n\n[1] \"TFCHK: Transfer function may not be proper and may lead to errors. Num &gt; Den\"\n\n\n\n\n\n\n\n\n\nSulla base dei diagrammi di bode ed osservando lo spettro dell’uscita che segue, è evidente che le componenti oltre i \\(2.25\\,\\mathrm{Hz}\\) verranno amplificate.\n\n\n\n\n\n\n\n\n\nA questo punto viene effettuata la compensazione:\n\n# Compensazione dell'uscita\nu &lt;- s %&gt;% select(t, u, u_n) %&gt;%\n  mutate(\n    u_comp = dyn_compensation(y, H, name_sig = \"y\")$u\n  )\n\n\n\n\n\n\n\nCome anticipato l’inversione della FdT comporta la ricostruzione di un segnale abbastanza rumoroso; perdipiù la coda destra presenta delle forti amplificazioni - derivanti presumibilmente dal taglio delle code durante il padding -. Per comprendere il tipo di rumore e quali componenti lo costituiscano si osserva lo spettro del segnale.\n\n\n\n\n\n\n\n\n\nIl segnale compensato presenta un fondo spettrale diffuso e privo di struttura armonica evidente, compatibile con un rumore di tipo bianco. Pertanto, ai fini di eliminare quest’ultimo e ricostruire il segnale utile come somma delle sole componenti armoniche dominanti, viene realizzata una maschera in frequenza che annulla le componenti associate al fondo spettrale.\n\nN &lt;- nrow(u)\nk &lt;- 0:(N-1)\n\n# La soglia per selezionare le componenti predominanti\n# viene individuata visivamente dallo spettro, ricordando\n# che lo spettro completo (bilatero), possiede metà dell'energia\n# spettrale di quello monolarero\nthreashold &lt;- 0.04\n\n\nu_spectrum &lt;- tibble(\n    f = ifelse(k &lt;= N/2, k, k-N) * fs/N,\n    U = fft(u$u_comp),\n    mask = Mod(U)/N &gt; threashold,        # vettore di booleani\n    U_filtered = U*mask\n)\n\nu_spectrum %&gt;% dplyr::filter(f&gt;=0) %&gt;%\n  mutate(mod = 2*Mod(U_filtered)/N) %&gt;% \n  ggplot(aes(f, mod)) + \n  geom_spoke(aes(y = 0, radius = mod, angle = pi/2), color = \"#F8766D\") +\n  geom_point(color = \"#F8766D\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\", title = \"Spettro del input mascherato\")\n\n\n\n\n\n\n\n\nNota: la componente DC viene processata dalla maschera perché visivamente si vede (e si sa a priori in questo caso) che il segnale di ingresso è a media nulla. In generale sarebbe buona pratica sottrarre tale componente.\n\n# Segnale nel tempo mediante FFT^-1\nu &lt;- u %&gt;% mutate(\n    u_new = Re(fft(u_spectrum$U_filtered, inverse = T))/N\n  )\n\n\n\n\n\n\n\nSi conclude visivamente come adesso il segnale compensato tenda a sovrapporsi su quello ideale, peraltro con nessuna particolare discrepanza sulle code, a differenza del caso precedente. Cionostante, si osserva un lieve ritardo che va accumulandosi nel tempo. Come prova di questo fenomeno, si può osservare la differenza di fase tra i due segnali.\n\nphase &lt;- tibble(\n    f = ifelse(k &lt;= N/2, k, k-N) * fs/N,\n    U_id = fft(u$u),\n    U_mask = fft(u$u_new),\n    diff = (Arg(U_id) - Arg(U_mask))*180/pi\n) %&gt;% dplyr::filter(f&gt;0)  # fase antisimmetrica rispetto alla frequenza\n\n# Regressione qualitativa per evidenziare l'andamento della differenza di fase\nphase.fit &lt;- loess(diff ~ f, data = phase, span = 0.5)\nphase$fit &lt;- predict(phase.fit)\n\nphase %&gt;% select(-U_id, -U_mask) %&gt;% pivot_longer(-f) %&gt;%\n  ggplot(aes(x = f, y = value, color = name)) +\n  geom_line() +\n  scale_color_discrete(labels = c(diff = latex2exp::TeX(\"$\\\\Delta \\\\varphi\"), fit = \"Fit\")) +\n  labs(x = \"Frequenza (Hz)\", y = \"Fase (°)\", colour = \"Legenda\")\n\n\n\n\n\n\n\n\nÈ qualitativamente evidente come la differenza di fase non sia costante, che spiega il ritardo accumulato nel tempo. La ragione di questo fatto potrebbe risiedere in errori numerici, come per esempio nella computazione di fft() e della sua inversa o di freqresp relativa alla FdT. D’altro canto, si può supporre che il ritardo non costante nel tempo sia attribuibile ad una fase non lineare della FdT inversa in corrispondenza delle armoniche del segnale (cfr. i diagrammi di Bode della FdT inversa). Ad ogni modo, è molto contenuto tale ritardo, percui ai fini dell’esercitazione si può accettare il risultato."
  },
  {
    "objectID": "ex3.html",
    "href": "ex3.html",
    "title": "Esercitazione 3",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie.\n\n1 Funzione di trasferimento e risposta al gradino\n\nFunzione di trasferimento e risposta al gradino.\n\nIl principio alla base per ricavare la funzione di trasferimento del sistema è il bilancio delle potenze termiche scambiate:\n\\[\nm c \\frac{d}{dt} T(t) = \\alpha A(T_{amb}(t)-T(t)) \\overset{\\mathcal{F}}{\\longrightarrow} mc \\, j\\omega T(j\\omega) =\\alpha A (T_{amb}(j\\omega) - T(j\\omega)).\n\\]\nPerciò, bilanciando la potenza scambiata tra sonda (uscita del sistema) e guaina, si ottiene:\n\\[\\begin{aligned}\nm_s c_s \\, j\\omega T_s(j\\omega) &= \\alpha_{gs} A_{gs} (T_{g}(j\\omega) - T_s(j\\omega)) \\\\\n\\Leftrightarrow \\frac{T_s(j\\omega)}{T_g(j\\omega)} &= \\frac{1}{\\tau_1 \\, j\\omega + 1} ,\n\\end{aligned}\\]\ndove \\(\\tau_2 = \\frac{M_s c_s}{\\alpha_{gs} A_{gs}}\\).\nMediante gli stessi procedimenti, si può esprimere anche la potenza scambiata tra il misurando (input del sistema) e la guaina:\n\\[\\begin{aligned}\nm_g c_g \\, j\\omega T_g(j\\omega) &= \\alpha_{mg} A_{gs} (T_{m}(j\\omega) - T_g(j\\omega)) \\\\\n\\Leftrightarrow \\frac{T_g(j\\omega)}{T_m(j\\omega)} &= \\frac{1}{\\tau_2 \\, j\\omega + 1} ,\n\\end{aligned}\\]\ndove dove \\(\\tau_1 = \\frac{M_g c_g}{\\alpha_{mg} A_{mg}}\\).\nPertanto, esprimendo \\(T_g\\) in funzione di \\(T_m\\), si ricava la funzione di risposta in frequenza tra misura (sonda) e misurando:\n\\[\nH(j\\omega) = \\frac{1}{\\tau_1 \\tau_2 (j \\omega)^2 + (\\tau_1 + \\tau_2)j\\omega + 1}.\n\\]\nRiguardo alla risposta allo scalino da \\(T_i\\) a \\(T_f\\) nelle condizioni di \\(\\tau_1 &gt; \\tau_2\\), si modella il gradino come segue, traslato di \\(T_i\\):\n\\[\\begin{aligned}\nT_m(t) = T_i + (T_f - T_i)\\,\\text{sca}(t) &\\overset{T_i = \\text{cost}}{\\Leftrightarrow} \\vartheta_m(t) := T_m(t) - T_i = (T_f - T_i)\\,\\text{sca}(t) \\\\\n&\\overset{\\mathcal{L}}{\\longrightarrow} \\Theta_m(s) = (T_f - T_i)\\frac{1}s .\n\\end{aligned}\\]\nSi definisce anche l’uscita traslata di \\(T_i\\):\n\\[\n\\vartheta_s(t) := T_s(t) - T_i \\overset{\\mathcal{L}}{\\longrightarrow} \\Theta_s(s).\n\\]\nIn virtù della natura LTI del sistema, la risposta allo scalino nel dominio della frequenza è pari a\n\\[\n\\Theta_s(s) = H(s) \\cdot (T_f - T_i)\\frac{1}s.\n\\]\nMediante la scomposizione per fratti semplici e poi anti-trasformando, si ottiene la risposta nel dominio nel tempo:\n\\[\nT_s(t) = T_f + (T_i+T_f) \\cdot \\left( \\frac{\\tau_1}{\\tau_1 - \\tau_2} e^{-\\frac{t}{\\tau_1}} - \\frac{\\tau_2}{\\tau_1 - \\tau_2} e^{-\\frac{t}{\\tau_2}} \\right) .\n\\]\n\n\n2 Segnale campionato\nIl set di dati è disponibile a questo link.\n\ndf &lt;- read.table(\"datiPT100_2005Taratura.txt\", header=FALSE, sep=\"\\t\", dec=\",\", stringsAsFactors=FALSE)\ncolnames(df) &lt;- c(\"t\", \"temp\", \"temp_f\")\n\ndf &lt;- df %&gt;% dplyr::filter(t &gt;= 150) %&gt;% select(-temp_f) %&gt;%\n  mutate(t = t - 150)\n\ndf %&gt;% plot_ly(x = ~t, y = ~temp) %&gt;%\n  add_lines() %&gt;% \n  layout(xaxis = list(title=\"Tempo (s)\"), yaxis = list(title=\"Temperatura (°C)\"), title=\"Segnale di temperatura campionato\")\n\n\n\n\n\n\n# Verificato campionamento regolare con media e sd\nfs &lt;- 1/(df$t[2]-df$t[1]) # freq. di campionamento\nTa &lt;- max(df$t) # tempo di acquisizione: primo istante a 0 sec\n\nParametri di campionamento (regolare):\n\n\\(f_s =5.99\\,\\mathrm{Hz}\\)\n\\(T_a =244.67\\,\\mathrm{s}\\)\n\n\n\n3 Taratura costanti \\(\\tau_1\\) e \\(\\tau_2\\)\n\nRegressione sulle sole costanti di tempo.\n\n\nt0 &lt;- 28                        # soglia temporale tra plateau e transizione\nTi &lt;- mean(df$temp[df$t &lt; t0])\nTf &lt;- 82                        # attribuito visivamente\n\n# Modello fisico: risposta allo scalino\ntemperature &lt;- function(t, t0, Ti, Tf, tau1, tau2) {\n  ifelse(\n    t &lt; t0,\n    Ti,\n    Tf + (Ti-Tf)*(\n      tau1/(tau1-tau2)*exp( - (t-t0)/tau1 ) -\n      tau2/(tau1-tau2)*exp( - (t-t0)/tau2 )\n    )\n  )\n}\n\ndf.nls &lt;- nls(temp ~ temperature(t, t0, Ti, Tf, tau1, tau2),\n              data = df, start = list(tau1 = 30, tau2=25)\n            )\nsummary(df.nls)\n\n\nFormula: temp ~ temperature(t, t0, Ti, Tf, tau1, tau2)\n\nParameters:\n     Estimate Std. Error t value Pr(&gt;|t|)    \ntau1 31.41414    0.06063  518.10   &lt;2e-16 ***\ntau2  0.86715    0.04374   19.83   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4801 on 1467 degrees of freedom\n\nNumber of iterations to convergence: 9 \nAchieved convergence tolerance: 4.686e-06\n\n\n\ndf &lt;- df %&gt;% add_predictions(df.nls) %&gt;% add_residuals(df.nls)\n\np1 &lt;- df %&gt;% ggplot(aes(x = t)) +\n  geom_line(aes(y = temp)) +\n  geom_line(aes( y = pred), color = \"red\") +\n  labs(x=\"Tempo (s)\", y=\"Temperatura (°C)\")\n\np2 &lt;- df %&gt;% ggplot(aes(x = t, y = resid)) +\n  geom_point() +\n  geom_vline(xintercept = as.numeric(coef(df.nls)[1]), color = \"orange\", linetype = 2) +\n  labs(x=\"Tempo (s)\", y=\"Residui (°C)\")\n\np1+p2\n\n\n\n\n\n\n\n\nOsservando i residui, è evidente un pattern di questi durante la fase di transizione che suggerisce un underfitting dei dati. Questo potrebbe essere sintomo che il modello fisico ipotizzato non sia adeguato. Peraltro, i parametri regrediti suggeriscono un comportamento predominante dalla costante di tempo \\(\\tau_1\\).\nTuttavia, graficamente è chiaro come la regressione nls segua bene le misure sperimentali e comunque si parla di una dispersione dei residui di circa \\(\\pm1 \\,\\mathrm{°C}\\).\n\n\n4 Taratura su tutti i parametri\n\nRegressione su tutti i parametri.\n\n\nparams &lt;- list(t0 = t0,\n               Ti = Ti,\n               Tf = Tf,\n               tau1 = as.numeric(coef(df.nls)[1]),\n               tau2 = as.numeric(coef(df.nls)[2])\n            )\n\ndf.nls2 &lt;- nls(temp ~ temperature(t, t0, Ti, Tf, tau1, tau2),\n               data = df, start = params)\nsummary(df.nls2)\n\n\nFormula: temp ~ temperature(t, t0, Ti, Tf, tau1, tau2)\n\nParameters:\n     Estimate Std. Error t value Pr(&gt;|t|)    \nt0   24.89962    0.13417  185.58   &lt;2e-16 ***\nTi   28.12231    0.03563  789.33   &lt;2e-16 ***\nTf   81.80832    0.01983 4124.48   &lt;2e-16 ***\ntau1 30.08639    0.10480  287.10   &lt;2e-16 ***\ntau2  4.71385    0.16979   27.76   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4449 on 1464 degrees of freedom\n\nNumber of iterations to convergence: 12 \nAchieved convergence tolerance: 5.334e-06\n\n\n\ndf &lt;- df %&gt;% add_predictions(df.nls2) %&gt;% add_residuals(df.nls2)\n\np1 &lt;- df %&gt;% ggplot(aes(x = t)) +\n  geom_line(aes(y = temp)) +\n  geom_line(aes( y = pred), color = \"red\") +\n  labs(x=\"Tempo (s)\", y=\"Temperatura (°C)\")\n\np2 &lt;- df %&gt;% ggplot(aes(x = t, y = resid)) +\n  geom_point() +\n  geom_vline(xintercept = as.numeric(coef(df.nls2)[1]), color = \"orange\", linetype = 2) +\n  labs(x=\"Tempo (s)\", y=\"Residui (°C)\")\n\np1+p2\n\n\n\n\n\n\n\n\nAnche in questo caso i residui continuano a mostrare un determinato andamento nella fase di transizione, ma visivamente la regressione si ben adatta alle misure sperimentali.\n\n\n5 Intervallo di confidenza dei parametri\n\nIntervallo di confidenza dei parametri mediante bootstrap.\n\nL’intervallo di confidenza (IC) viene calcolato al \\(95\\%\\): ossia è quell’intervallo al quale i parametri regrediti appartengono con tale probabilità.\n\n# Funzione che calcola i parametri di nls ad ogni ripetizione \n# per questa ragione sono delle statistiche\nstats &lt;- function(temp, data) {\n  fit &lt;- nls(temp ~ temperature(t, t0, Ti, Tf, tau1, tau2), \n             data = data, start = params)\n  return(fit$m$getPars())\n}\n\n# Bootstrap NON parametrico (con reinserimento di default)\ndf.b &lt;- boot(df, \\(x,i) stats(x[i, \"temp\"], x[i,]), R=10^4)\n\ndf.b\n\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = df, statistic = function(x, i) stats(x[i, \"temp\"], \n    x[i, ]), R = 10^4)\n\n\nBootstrap Statistics :\n     original        bias    std. error\nt1* 24.899622 -0.0189276255  0.30509104\nt2* 28.122310 -0.0006834044  0.03664990\nt3* 81.808320 -0.0011842300  0.02428726\nt4* 30.086388 -0.0158893550  0.16456731\nt5*  4.713854  0.0295549131  0.39214482\n\n\nÈ verificato che le stime regredite coincidono con la regressione precedente, per cui si accetta il calcolo senza ulteriori dimostrazioni (e.g. un grafico QQ di ciascun parametro per capire se il numero di ripetizioni \\(R\\) è adeguato).\n\n# Intervallo di confidenza al 95% (metodo percentile)\nci &lt;- list(\n  t0 = boot.ci(df.b, type = \"perc\", index = 1)$percent[4:5],\n  Ti = boot.ci(df.b, type = \"perc\", index = 2)$percent[4:5],\n  Tf = boot.ci(df.b, type = \"perc\", index = 3)$percent[4:5],\n  tau1 = boot.ci(df.b, type = \"perc\", index = 4)$percent[4:5],\n  tau2 = boot.ci(df.b, type = \"perc\", index = 5)$percent[4:5]\n)\n\nGraficando l’IC, si mostra quanto sia incerta la stima della curva regredita.\nInteressanti sono gli IC relativi a \\(t_0, T_i\\) e \\(T_f\\).\n\n\n\n\n\n\n\n\n\nMentre su tutta la curva, combinando i diversi IC, si ottiene:\n\n# Funzione che calcola l'estremo alto o basso dell'IC\n# per ogni possibile combinazione degli estremi di IC\n# di ciascun parametro\nf_conf &lt;- function(t, temperature, ci, upper=TRUE) {\n  df &lt;- expand.grid(ci)       # ogni possibile combinazione di IC\n  df$temp &lt;- with(df, temperature(t, t0, Ti, Tf, tau1, tau2))\n  ifelse(upper, max(df$temp), min(df$temp))\n}\n\ndf %&gt;% mutate(\n  lower = map_dbl(t, ~f_conf(., temperature, ci, upper=FALSE)),\n  upper = map_dbl(t, ~f_conf(., temperature, ci))\n) %&gt;% ggplot(aes(x=t)) +\n  geom_ribbon(aes(ymin = lower, ymax = upper), fill=\"blue\", alpha=.5) +\n  geom_line(aes(y=temp)) +\n  geom_line(aes(y=pred), color=\"red\") +\n  labs(x=\"Tempo (s)\", y=\"Temperatura (°C)\")\n\n\n\n\n\n\n\n\nSi osserva come l’incertezza nella fase di transizione risulti più ampia, verosimilmente riconducibile alla stima di \\(\\tau_1\\) e \\(\\tau_2\\). Tale comportamento può indicare una parziale inadeguatezza del modello fisico adottato oppure una difficoltà di nls nel raggiungere una soluzione ottimale."
  },
  {
    "objectID": "ex1.html",
    "href": "ex1.html",
    "title": "Esercitazione 1",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie.\nParametri di campionamento che verranno considerati nell’analisi:\n# Campionamento regolare\nfs &lt;- 1000      # freq. di campionamento\nTs &lt;- 1/fs      # periodo di campionamento"
  },
  {
    "objectID": "ex1.html#ricostruzione-mediante-serie-di-fourier",
    "href": "ex1.html#ricostruzione-mediante-serie-di-fourier",
    "title": "Esercitazione 1",
    "section": "1.1 Ricostruzione mediante serie di Fourier",
    "text": "1.1 Ricostruzione mediante serie di Fourier\nIl segnale viene ricostruito mediante le serie di Fourier, in cui l’\\(n\\)-esimo elemento vale:\n\\[\np[n] = a_0 + \\sum_{k = 1}^{K} a_k \\cos[2\\pi k f_0 \\, n] + \\sum_{k = 1}^{K} a_k \\sin[2\\pi k f_0  \\, n] ,\n\\]\ndove \\(f_0\\) è la frequenza fondamentale, \\(K\\) è il numero totale di componenti armoniche e \\(a_k, b_k\\) sono le \\(k\\)-esime componenti, risultato della scomposizione su basi orto-normali. Si osservi che la componente in DC non viene divisa per 2, perché è calcolata come la media del segnale, anziché il doppio della media (come da teoria della trasformata).\nLa \\(k\\)-esima componente avrà frequenza pari a \\(f_k = k f_0 = \\frac{k}{T_a}\\), dove \\(T_a = 10\\,\\mathrm{s}\\) è il tempo di acquisizione. Perciò, in virtù del Teorema di Nyquist-Shannon, deve valere la seguente disuguaglianza, per la quale si calcola la massima componente:\n\\[\nf_{max} = \\frac{k_{max}}{T_a} \\leq \\frac{f_s}2 \\Leftrightarrow k_{max} = \\frac{f_s T_a}{2} = 5000,\n\\] con \\(f_s = 1000\\,\\mathrm{Hz}\\) la frequenza di campionamento.\n\nRicostruzione segnale anche con i coseni.\n\n\na0 &lt;- mean(sig_art$p_art)\n\n# La componente DC è ortogonale alle basi seno e cose\n# Per evitare errori numerici, quest'ultima viene sottratta al segnale\np_art_osc &lt;- sig_art$p_art - a0\n\nK &lt;- 500 # massimo possibile: 5e3\nf_fund &lt;- 1/Ta\n\ncomps_cos &lt;- map_dbl(1:K, \\(k) {\n  c &lt;- cos_k(sig_art$t, f_fund, k)\n  p_art_osc %ps% c/norm_ps(c)\n}) %&gt;% zapsmall()\n\ncomps_sin &lt;- map_dbl(1:K, \\(k) {\n  s &lt;- sin_k(sig_art$t, f_fund, k)\n  p_art_osc %ps% s/norm_ps(s)\n}) %&gt;% zapsmall()\n\ncomps_sin[1:50]\n\n [1]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n [8]  0.000000  0.000000  9.340245  0.000000  0.000000  0.000000  0.000000\n[15]  0.000000  0.000000  0.000000  0.000000  0.000000  3.153407  0.000000\n[22]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n[29]  0.000000  3.164646  0.000000  0.000000  0.000000  0.000000  0.000000\n[36]  0.000000  0.000000  0.000000  0.000000  1.965583  0.000000  0.000000\n[43]  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000\n[50] -0.061118\n\n\n\nRoutine mediante reduce.\n\n\n# Implementazione mediante reduce\nsig_art &lt;- sig_art %&gt;% mutate(\n  p_art_k = a0 + reduce(1:K, \\(acc, k) {\n    c &lt;- cos_k(t, f_fund, k)\n    s &lt;- sin_k(t, f_fund, k)\n    acc + comps_cos[k] * c/norm_ps(c) + comps_sin[k] * s/norm_ps(s)\n  }, .init = rep(0, n()))\n)\n\nplot_ly() %&gt;%\n  add_lines(x = sig_art$t, y = sig_art$p_art, name = \"Originale\") %&gt;%\n  add_lines(x = sig_art$t, y = sig_art$p_art_k, name = \"Ricostruito\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"Pressione (mmHg)\"), title = \"Ricostruzione del segnale\")"
  },
  {
    "objectID": "ex1.html#analisi-statica",
    "href": "ex1.html#analisi-statica",
    "title": "Esercitazione 1",
    "section": "3.1 Analisi statica",
    "text": "3.1 Analisi statica\n\nAnalisi statica dei residui.\n\n\n# Traslo il tempo a 0: fa comodo partire da lì\np.flt_5Hz &lt;- p.flt_5Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;%  \n  mutate(eps = p_k - p_flt)\n\np.flt_2Hz &lt;- p.flt_2Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;% \n  mutate(eps = p_k - p_flt)\n\np.flt_7Hz &lt;- p.flt_7Hz %&gt;% mutate(n=n-n[1], t = t-t[1]) %&gt;% \n  mutate(eps = p_k - p_flt)\n\nbind_rows(\n  p.flt_2Hz %&gt;% mutate(case = \"2 Hz\"),\n  p.flt_5Hz %&gt;% mutate(case = \"5 Hz\"),\n  p.flt_7Hz %&gt;% mutate(case = \"7 Hz\")\n) %&gt;% pivot_longer(\n  cols = c(p_k, p_flt)\n) %&gt;% mutate(\n    name = factor(name, levels = c(\"p_k\", \"p_flt\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(\n    \"p_k\" = \"Ricostruito\",\n    \"p_flt\" = \"Filtrato\"\n  )) +\n  facet_wrap(~ case, ncol = 1, scales = \"free_x\") +\n  labs(x = \"Tempo (s)\", y = \"Pressione (mmHg)\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\n\nbind_rows(\n  p.flt_2Hz %&gt;% mutate(caso = \"2 Hz\"),\n  p.flt_5Hz %&gt;% mutate(caso = \"5 Hz\"),\n  p.flt_7Hz %&gt;% mutate(caso = \"7 Hz\")\n) %&gt;% ggplot(aes(x = t, y = eps, colour = caso)) +\n  geom_point(size = 0.6, alpha = 0.6) +\n  labs(x = \"Tempo (s)\", y = \"Residui (mmHg)\", colour = latex2exp::TeX(\"$f_c\"))\n\n\n\n\n\n\n\n\nDai grafici soprastanti è evidente come anticipare il taglio distorga il segnale da quello di riferimento."
  },
  {
    "objectID": "ex1.html#analisi-in-frequenza",
    "href": "ex1.html#analisi-in-frequenza",
    "title": "Esercitazione 1",
    "section": "3.2 Analisi in frequenza",
    "text": "3.2 Analisi in frequenza\n\nAnalisi in frequenza dei residui.\n\n\n# Funzione per automatizzare il calcolo dello spettro\ncompute_fft &lt;- function(df, Ta, N, name_sig, monolateral = TRUE) {\n  \n  df &lt;- df %&gt;% mutate(\n    f = n/Ta,\n    fft = fft({{ name_sig }}),\n    mod = ifelse(monolateral, (2-(f==0)), 1) * Mod(fft) / length(n),\n    phase = Arg(fft)/pi*180\n  )\n  \n  if(monolateral)\n    return(df %&gt;% slice_head(n = floor(N/2)))\n  \n  df\n}\n\n\n# Nuovo tempo di campionamento (a causa dell'eliminazione delle code)\nTa &lt;- max(p.flt_2Hz$t) + 1/fs\nN &lt;- length(p.flt_2Hz$n)\n\n# Spettro dei segnali senza la componenti a f=0\np.flt_2Hz.fft &lt;- compute_fft(p.flt_2Hz, Ta, N, eps) %&gt;% slice(-1)\np.flt_5Hz.fft &lt;- compute_fft(p.flt_5Hz, Ta, N, eps) %&gt;% slice(-1)\np.flt_7Hz.fft &lt;- compute_fft(p.flt_7Hz, Ta, N, eps) %&gt;% slice(-1)\n\nbind_rows(\n  p.flt_2Hz.fft %&gt;% mutate(caso = \"2 Hz\"),\n  p.flt_5Hz.fft %&gt;% mutate(caso = \"5 Hz\"),\n  p.flt_7Hz.fft %&gt;% mutate(caso = \"7 Hz\")\n) %&gt;% dplyr::filter(f &lt; 50) %&gt;% \n  ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(angle = pi/2, y=0, radius = mod), linewidth = 0.2, colour = \"#F8766D\") +\n  geom_point(colour = \"#F8766D\") +\n  facet_wrap(~ caso, ncol = 1, scales = \"free_x\") +\n  labs(\n    x = \"Frequenza (Hz)\",\n    y = \"Ampiezza Residui (mmHg)\",\n    title = \"Spettri dei segnali filtrati\"\n  )\n\n\n\n\n\n\n\n\n\ntmp &lt;- list(fc_2 = p.flt_2Hz, fc_5 = p.flt_5Hz, fc_7 = p.flt_7Hz)\n\nstats &lt;-  tibble(\n  fc = c(\"2 Hz\", \"5 Hz\", \"7 Hz\"),\n  mean = map_dbl(tmp, ~ mean(.x$eps)),\n  sd = map_dbl(tmp, ~ sd(.x$eps))\n)\n\nknitr::kable(stats, digits = 2, caption = \"Statistiche dei residui\")\n\n\nStatistiche dei residui\n\n\nfc\nmean\nsd\n\n\n\n\n2 Hz\n0.11\n6.01\n\n\n5 Hz\n0.01\n1.74\n\n\n7 Hz\n-0.01\n0.71\n\n\n\n\n\nAnche osservando lo spettro dei residui è chiaro come avere una frequenza di taglio troppo bassa porti ad allontanarsi dall’andamento nominale. Infatti la dispersione dei residui tende ad aumentare (si guardi al valore di deviazione standard).\n\nFrequenza di taglio finale.\n\nDunque, per concludere, da un lato non è opportuno filtrare troppo tardi, poiché non verrebbe filtrato sufficientemente il rumore del segnale. Dall’altra, anticipare eccessivamente il taglio implica una distorsione dal segnale di riferimento, di cui un buon indicatore è la deviazione standard dei residui; questo fenomeno è dovuto a una soverchiante attenuazione di componenti in frequenza, magari proprie del segnale nominale stesso. Quindi, sulla base delle precedenti osservazioni, si sceglie una frequenza di taglio pari a \\(f_c = 7\\,\\mathrm{Hz}\\), ritenuta la più approssimativa del segnale ricostruito con Fourier."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Esercitazioni di esame",
    "section": "",
    "text": "Questo sito contiene la raccolta di esercitazioni da consegnare all’esame di Misure Industriali, del corso di Ingegneria Industriale, presso l’Università di Trento.\nLe esercitazioni fanno riferimento al sito relativo al corso di insegnamento.\n\nQuesti riquadri servono a mettere in rilievo quando viene data risposta ai quesiti dell’esercitazione.\n\n\n1 Contenuti\n\nLibrerie:\n\ndig_signal_proc.R: funzioni relative al digital signal processing\ngraphics.R: funzioni relative alla formattazione della grafica\n\nEsercitazione 1 - Segnale di onda pressoria\nEsercitazione 2 - Modulazione di ampiezza\nEsercitazione 3 - Taratura dinamica tramite regressione non lineare\nEsercitazione 4 - Compensazione dinamica\nEsercitazione 5- Inversione delle armoniche pure"
  },
  {
    "objectID": "ex2.html",
    "href": "ex2.html",
    "title": "Esercitazione 2",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie."
  },
  {
    "objectID": "ex2.html#modulazione",
    "href": "ex2.html#modulazione",
    "title": "Esercitazione 2",
    "section": "2.1 Modulazione",
    "text": "2.1 Modulazione\n\n# Onda portante: carrier &lt;- cos(2 * pi * fp * t)\n# Aggiungiamo alla struttura associata alla misura il segnale modulato:\nym &lt;- ym %&gt;% mutate(\n    yn_m = (1 + m * ym$yn) * cos(2 * pi * fp * t),\n    fft_m = fft(yn_m),\n    intensity_m = Mod(fft_m) / length(t)*2,\n    phase_m = Arg(fft_m)/pi*180\n  )\n\nym %&gt;% pivot_longer(\n    cols = c(yn, yn_m)\n  ) %&gt;% mutate(\n    name = factor(name, levels = c(\"yn_m\", \"yn\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(\n    \"yn_m\" = \"Modulato\",\n    \"yn\" = \"Misurato\"\n  )) +\n  labs(x = \"Tempo (s)\", y = \"Segnale\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\n\nplot_ly() %&gt;%\n  add_bars(data = ym, x = ~f, y = ~intensity, name = \"Segnale\", marker = list(color = \"blue\")) %&gt;%\n  add_bars(x = r$f, y = r$intensity, name = \"Rumore\", marker = list(color = \"red\")) %&gt;%\n  add_bars(data = ym, x = ~f, y = ~intensity_m, name = \"Segnale Modulato\", marker = list(color = \"green\")) %&gt;%\n  layout(title = \"Spettro di Intensità\",\n       xaxis = list(title = \"Frequenza (Hz)\", range = c(0, 500), showgrid = TRUE),\n       yaxis = list(title = \"Intensità\", showgrid = TRUE),\n       legend = list(x = 0.25, y = 0.9))"
  },
  {
    "objectID": "ex2.html#esposizione-del-segnale-modulato-al-rumore",
    "href": "ex2.html#esposizione-del-segnale-modulato-al-rumore",
    "title": "Esercitazione 2",
    "section": "2.2 Esposizione del segnale modulato al rumore",
    "text": "2.2 Esposizione del segnale modulato al rumore\n\n# Effetto interferente sul segnale modulato:\nym &lt;- ym %&gt;% mutate(\n    yn_m_n = yn_m + r$y,\n    fft_m = fft(yn_m_n),\n    intensity_m = Mod(fft_m) / length(t)*2,\n    phase_m = Arg(fft_m)/pi*180\n  )\n\nplot_ly() %&gt;%\n  add_lines(data = ym, x = ~f, y = ~intensity_m, type = \"bar\", name = \"Segnale\", marker = list(color= \"blue\")) %&gt;%\n  layout(title = \"Spettro segnale modulato affetto da rumore\",\n       xaxis = list(title = \"Frequenza (Hz)\", range = c(0, 500), showgrid = TRUE),\n       yaxis = list(title = \"Intensità\", showgrid = TRUE))\n\n\n\n\n\n\nplot_ly() %&gt;%\n  add_lines(data = ym, x = ~t, y = ~yn_m, name = \"Segnale modulato\") %&gt;%\n  add_lines(data = ym, x = ~t, y = ~yn_m_n, name = \"Con effetto interferente\") %&gt;%\n  layout(title = \"Segnale modulato affetto da rumore\", \n         xaxis = list(title = \"Tempo (s)\"), \n         yaxis = list(title = \"Segnale\"))"
  },
  {
    "objectID": "ex2.html#eliminazione-del-rumore-interferente",
    "href": "ex2.html#eliminazione-del-rumore-interferente",
    "title": "Esercitazione 2",
    "section": "3.1 Eliminazione del rumore interferente",
    "text": "3.1 Eliminazione del rumore interferente\nOsservando lo spettro del segnale modulato esposto al rumore interferente, è evidente come le componenti di rumore siano separate da quelle del segnale modulato, che si trova ad alta frequenza. Pertanto, può essere implementato un filtro digitale passa-alto offline per selezionare solo quello modulato.\n\nFiltro passa-alto.\n\nInizialmente è stato scelto un filtro Butterworth, il cui ordine e frequenza di taglio sono stati selezionati a tentativi, affinché attenuassero il più possibile l’ultima componente di rumore a 135 Hz senza ridurre eccessivamente il segnale modulato.\n\nf_cutoff &lt;- 200\nflt.butter &lt;- butter(4, f_cutoff/(fc/2), type = \"high\")  # filtro Butterworth passa-alto\n\nggbodeplot_digital(flt.butter, fc, fmin = 1e1) + geom_vline(xintercept = f_cutoff, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- tibble(\n  t = ym$t,\n  yn = ym$yn,\n  yn_m = ym$yn_m,\n  yn_m_n = ym$yn_m_n,\n  yn_m_n.flt = signal::filtfilt(flt.butter, yn_m_n),   # estrae il segnale modulato\n  f = 0:(length(t)-1)/max(t),\n  fft = fft(yn_m_n.flt),\n  intensity = Mod(fft)/length(t)*2,\n  phase = Arg(fft)*180/pi\n) \n\nym.flt %&gt;% dplyr::filter(f &lt;= fc/2) %&gt;% plot_ly(x = ~f) %&gt;%\n  add_lines(y = ~intensity) %&gt;%\n  layout(xaxis = list(title=\"Frequenza (Hz)\"), yaxis=list(title=\"Intensità\"), title=\"Filtraggio del segnale modulato con filtro Butterworth\")\n\n\n\n\n\nTuttavia, nello spettro compare ancora una componente di rumore e il segnale in banda trasmessa risulta leggermente attenuato. Dunque, viene implementato un filtro di tipo Chebishev II, il quale a parità di ordine del Butterfly possiede una banda di transizione più ripida. Questo genere di filtro introdurrà un ripple in banda di stop, che però verrà attenuato mediante un filtraggio delle basse frequenze, che è richiesto per eliminare il rumore bianco. Nello specifico, a tentativi è stato scelto un taglio pari alla componente di più alta frequenza del rumore interferente.\n\nf_cutoff &lt;- max(pars_r$f)\nflt.cheby &lt;- cheby2(4, 20, f_cutoff/(fc/2), type = \"high\")  # N.B.: 20dB di riduzione del ripple in stop band\n\nggbodeplot_digital(flt.cheby, fc, fmin = 1e1) + geom_vline(xintercept = f_cutoff, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- ym.flt %&gt;% mutate(\n  yn_m_n.flt = signal::filtfilt(flt.cheby, yn_m_n),   # estrae il segnale modulato\n  f = 0:(length(t)-1)/max(t),\n  fft = fft(yn_m_n.flt),\n  intensity = Mod(fft)/length(t)*2,\n  phase = Arg(fft)*180/pi\n) \n\nym.flt %&gt;% dplyr::filter(f &lt;= fc/2) %&gt;% plot_ly(x = ~f) %&gt;%\n  add_lines(y = ~intensity) %&gt;%\n  layout(xaxis = list(title=\"Frequenza (Hz)\"), yaxis=list(title=\"Intensità\"), title=\"Filtraggio del segnale modulato con filtro Chebyshev II\")\n\n\n\n\n\nInfatti, ora lo spettro mostra il rumore essere quasi inesistente e il segnale trasmesso quasi privo di attenuazione.\n\nym.flt %&gt;% plot_ly(x = ~t) %&gt;%\n  add_lines(y = ~yn_m_n, name = \"Con rumore interferente\") %&gt;%\n  add_lines(y = ~yn_m, name = \"Modulato\") %&gt;%\n  add_lines(y = ~yn_m_n.flt, name = \"Filtrato\") %&gt;%\n  layout(xaxis = list(title = \"Tempo (s)\"), yaxis = list(title = \"Segnale\"), title = \"Estrazione del segnale modulato\")\n\n\n\n\n\nA conferma del corretto procedimento di filtraggio è il fatto che il segnale ottenuto corrisponde a quello modulato prima dell’esposizione al rumore."
  },
  {
    "objectID": "ex2.html#demodulazione",
    "href": "ex2.html#demodulazione",
    "title": "Esercitazione 2",
    "section": "3.2 Demodulazione",
    "text": "3.2 Demodulazione\n\nDemodulazione.\n\nIl processo di demodulazione è quello che permette di separare il segnale misurato dalla portante. A tal fine, viene scelta la demodulazione sincrona [suggerimento ChatGPT], in cui il segnale modulato viene moltiplicato per un’armonica pura con stessa frequenza e fase della portante (per questo si chiama “sincrona”). Nello specifico, i passaggi da seguire sono i seguenti:\n\n:\n\n\\[\\begin{aligned}\ny_{mix} :&= y_{mod}(t) \\cdot \\cos(2\\pi f_p t) \\\\\n&= (1 + m y(t)) \\cos^2(2\\pi f_p t) \\\\\n&= (1+my(t))\\frac{1+\\cos(4\\pi f_p t)}{2} \\\\\n&= \\frac{1}2 (1+m y(t)) + \\frac{1}2 (1+my(t))\\cos(4 \\pi f_p t) .\n\\end{aligned}\\]\n\nFiltraggio passa-basso: il segnale ottenuto dal mixing è caratterizzato da una componente a bassa frequenza (pari al più a \\(f_{max}\\) del segnale misurato) ed una ad alta frequenza (pari a \\(2f_p\\)): \\[\nLP\\{y_{mix}\\}(f_{max} &lt; f_{cutoff} \\ll 2f_p) \\longrightarrow y_{flt} \\approx 1+my(t) .\n\\]\nRielaborazione matematica per ottenere il segnale misurato:\n\n\\[\n\\frac{1}m (y_{flt} - 1) = y(t) .\n\\]\nIn particolare, il filtro passa-basso permette anche di attenuare il ripple dal filtro Chebyshev e il rumore bianco.\n\nym.flt &lt;- ym.flt %&gt;% select(-fft, -intensity, -phase, -f) %&gt;% mutate(\n  y_mix = (2*yn_m_n.flt*cos(2*pi*fp*t) - 1)/m   # demodulazione + rielaborazione matematica\n)\n\n# Filtro passa-basso\n# Taglio al doppio della freq. max del segnale misurato\n# per far passare l'intero suo spettro\nf_cut2 &lt;- 2*max(pars_m$f)\nflt.butter.lp &lt;- butter(2, f_cut2/(fc/2))\n\nggbodeplot_digital(flt.butter.lp, fc, fmin = 1) + geom_vline(xintercept = f_cut2, linetype = 2, color = \"red\")\n\n\n\n\n\n\n\n\n\nym.flt &lt;- ym.flt %&gt;% mutate(\n  y_flt2 = filtfilt(flt.butter.lp, y_mix)\n)\n\nym.flt %&gt;% plot_ly(x = ~t) %&gt;%\n  add_lines(y = ~yn_m_n.flt, name = \"Filtrato\") %&gt;%\n  add_lines(y = ~y_flt2, name = \"Demodulato\") %&gt;%\n  layout(xaxis = list(title=\"Tempo (s)\"), yaxis=list(title=\"Segnale\"), title = \"Demodulazione\")\n\n\n\n\n\n\nComparazione con la misura originale.\n\n\nym.flt %&gt;% pivot_longer(cols = c(\"yn\", \"y_flt2\")) %&gt;%\n  mutate(\n    name = factor(name, levels = c(\"yn\", \"y_flt2\"))\n  ) %&gt;% ggplot(aes(x = t, y = value, colour = name)) +\n  geom_line() +\n  scale_colour_discrete(labels = c(yn = \"Originale\", y_flt2 = \"Demodulato\")) +\n  labs(x = \"Tempo (s)\", y = \"Segnale\", colour = \"Segnale\")\n\n\n\n\n\n\n\n\nSi osservi come il processo di demodulazione ha permesso anche di filtrare il rumore."
  },
  {
    "objectID": "ex4.html",
    "href": "ex4.html",
    "title": "Esercitazione 4",
    "section": "",
    "text": "Per la consegna dell’esercitazione si faccia riferimento a questo link. Mentre le librerie sono rimandate nell’icona Librerie."
  },
  {
    "objectID": "ex4.html#spettro-dei-segnali-misurati",
    "href": "ex4.html#spettro-dei-segnali-misurati",
    "title": "Esercitazione 4",
    "section": "2.1 Spettro dei segnali misurati",
    "text": "2.1 Spettro dei segnali misurati\n\nTa &lt;- max(u$t)\nun.fft &lt;- compute_fft(tmp, Ta, un)\nideal.fft &lt;- compute_fft(tmp, Ta, ideal)\nout.fft &lt;- compute_fft(tmp, Ta, out)\n\nbind_rows(\n  un.fft %&gt;% mutate(caso = \"Input\"),\n  ideal.fft %&gt;% mutate(caso = \"Output ideale\"),\n  out.fft %&gt;% mutate(caso = \"Output\")\n) %&gt;% dplyr::filter(f &lt; 1) %&gt;% \n  ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(angle = pi/2, y=0, radius = mod), linewidth = 0.2, colour = \"#F8766D\") +\n  geom_point(colour = \"#F8766D\") +\n  facet_wrap(~ caso, ncol = 1, scales = \"free_x\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\")\n\n\n\n\n\n\n\n\nNB: non si vede, ma il rumore bianco è presente. Provare ad ingrandire la sd del rumore addizionato a un."
  },
  {
    "objectID": "ex4.html#padding-simmetrico-a-zero",
    "href": "ex4.html#padding-simmetrico-a-zero",
    "title": "Esercitazione 4",
    "section": "3.1 Padding simmetrico a zero",
    "text": "3.1 Padding simmetrico a zero\n\n# Ampiezza padding\nM &lt;- 2*N\n\npad_left  &lt;- floor((M - N)/2)\npad_right &lt;- ceiling((M - N)/2)\nt_start &lt;- y$t[1] - pad_left * Ts\n\ny_ext &lt;- tibble(\n  t = seq(from = t_start, by = Ts, length.out = M),\n  y_pad = c(\n    rep(0, pad_left),\n    y$y_flt,\n    rep(0, pad_right)\n  )\n)\n\n# Verifica che il segnale sia centrato: deve restituire TRUE\n#all.equal(y_ext$y_pad[(pad_left+1):(pad_left+N)],y$y_flt)\n\n\n\n\n\n\n\n\n\n\n\n# Nuovo asse delle frequenze\nfreq &lt;- tibble(\n  k = 0:(M-1),\n  f = ifelse(k &lt;= M/2, k, k-M) * fs/M,   # FFT simmetrica nell'asse delle freq.\n  w = 2*pi*f\n)\n\nHiw &lt;- freqresp(H, freq$w)\n\ny_ext &lt;- y_ext %&gt;% mutate(\n  Y_pad = fft(y_pad),\n  U_pad = Y_pad/Hiw,\n  u_pad = Re(fft(U_pad, inverse = TRUE)) / M\n)\n\n# Scarto delle code di padding\nu_comp &lt;- u_comp %&gt;% mutate(\n  u_pad = y_ext$u_pad[(pad_left+1):(pad_left+N)]\n)\n\n\n\n\n\n\n\nQuesta volta il segnale compensato coincide molto bene con quello ideale. Ciononostante, si osserva ancora un alto contenuto in frequenza nelle code. Quest’ultimo viene eliminato mediante un’operazione di filtraggio.\n\n# Verifico lo spettro del segnale\ncompute_fft(u_comp, Ta, u_pad) %&gt;% dplyr::filter(f &lt; 2) %&gt;%\n  ggplot(aes(x = f, y = mod)) +\n  geom_spoke(aes(angle = pi/2, y=0, radius = mod), linewidth = 0.2, colour = \"#56B4E9\") +\n  geom_point(colour = \"#56B4E9\") +\n  labs(x = \"Frequenza (Hz)\", y = \"Intensità\", title = \"Spettro dell'ingresso compensato\")\n\n\n\n\n\n\n\n\n\nfc &lt;- 2\nflt &lt;- butter(2, 2*fc/fs)\n\nu_comp &lt;- u_comp %&gt;% mutate(\n  u_flt = signal::filtfilt(flt, u_pad)\n)\n\n\n\n\n\n\n\nAdesso si osserva che l’ingresso viene riprodotto fedelmente. Di seguito un confronto tra segnale di uscita e ingresso compensato:"
  },
  {
    "objectID": "graph_library.html",
    "href": "graph_library.html",
    "title": "Libreria per la grafica",
    "section": "",
    "text": "# This file contains some functions for graphics formatting\n\nggbodeplot_continous &lt;- function(tf, fs, fmin=1, fmax=NULL, df=0.01) {\n  \n  # Bode's plot in continous-time domain\n  # `tf`: transfer function\n  # `fs`: sampling freq.\n  \n  if (is.null(fmax)) fmax &lt;- fs/2\n  \n  # vector of points for each order of magnitude (OOM):\n  pts &lt;- 10^seq(0, 1, df) %&gt;% tail(-1)\n  # vector of OOMs:\n  ooms &lt;- 10^(floor(log10(fmin)):ceiling(log10(fmax)-1))\n  # combine pts and ooms:\n  freqs &lt;- as.vector(pts %o% ooms)\n  \n  # warning: bode wants pulsation!\n  bode(tf, freqs*2*pi) %&gt;% {\n    tibble(\n      f=.$w/(2*pi), \n      `Magnitude (dB)`=.$mag, \n      `Phase (deg)`=.$phase)} %&gt;%\n    pivot_longer(-f) %&gt;% \n    ggplot(aes(x=f, y=value)) +\n      geom_line() +\n      scale_x_log10(\n        breaks = 10^seq(floor(log10(fmin)), ceiling(log10(fmax))),\n        minor_breaks=scales::minor_breaks_n(10), \n        labels= ~ latex2exp::TeX(paste0(\"$10^{\", log10(.), \"}$\"))\n        ) +\n    facet_wrap(~name, nrow=2, scales=\"free\") +\n    labs(x=\"Frequency (Hz)\", y=\"\")\n}\n\nggbodeplot_digital &lt;- function(tf, fs, fmin=1e-3, fmax=NULL, npts=2000, xaxis = c(\"frequency\", \"omega\")) {\n  \n  # Bode's plot in discrete-time domain\n  # `tf`: transfer function\n  # `fs`: sampling freq.\n  # `xaxis`: defines whether plot the physical freq. or the discrete angular one\n  \n  xaxis &lt;- match.arg(xaxis)\n  if (is.null(fmax)) fmax &lt;- fs/2\n  \n  f &lt;- 10^seq(log10(fmin), log10(fmax), length.out = npts)  # physical frequency\n  w &lt;- 2*pi*f/fs                                            # discrete angular frequency (rad/sample) [0,π]\n  \n  H &lt;- freqz(tf$b, tf$a, w)                               # digital frequency response\n  \n  xtitle = ifelse(xaxis == \"frequency\", \"Frequency (Hz)\", latex2exp::TeX(\"Discrete \\\\omega (rad/sample)\"))\n  \n  p &lt;- tibble(\n    f = H$f * ifelse(xaxis == \"frequency\", fs/(2*pi), 1),    # H$f returns the previous `w`\n    `Magnitude (dB)` = 20*log10(Mod(H$h)),\n    `Phase (deg)` = Arg(H$h)*180/pi\n  ) %&gt;%\n    pivot_longer(-f) %&gt;%\n    ggplot(aes(x=f, y=value)) +\n    geom_line() +\n    scale_x_log10(\n      breaks = 10^seq(floor(log10(fmin)), ceiling(log10(fmax)), by = 1),\n      minor_breaks = scales::minor_breaks_n(10),\n      labels = ~ latex2exp::TeX(paste0(\"$10^{\", log10(.), \"}$\"))\n    ) +\n    facet_wrap(~name, nrow=2, scales=\"free\") +\n    labs(x=xtitle, y=\"\") \n  \n  if (xaxis==\"omega\") {\n    p &lt;- p + scale_x_log10(\n      breaks = 10^seq(floor(log10(2*pi*fmin/fs)), ceiling(log10(2*pi*fmax/fs)), by = 1),\n      minor_breaks = scales::minor_breaks_n(10),\n      labels = ~ latex2exp::TeX(paste0(\"$10^{\", log10(.), \"}$\"))\n    ) + \n      geom_vline(xintercept = pi, linetype = 4, color = \"blue\") +\n      annotate(\"text\", x = pi, y = Inf, label = expression(pi), vjust = 1.2, hjust = 1.2)\n  }\n  \n  # output\n  p\n}"
  }
]